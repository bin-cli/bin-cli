#!/usr/bin/env bash
################################################################################
# Bin - A simple task runner           Copyright (c) 2023-24 Dave James Miller #
# https://github.com/bin-cli/bin-cli   MIT License                             #
################################################################################

#region ==== SHELL OPTIONS =====================================================

set -euo pipefail
shopt -s nullglob

#endregion =====================================================================
#region ==== CONSTANTS =========================================================

# Version (set by build script - don't change in source file)
VERSION='v1.2.3-source'

# Executable
BIN_EXECUTABLE="$0"

# The BIN_TEST_ROOT env var is ignored in production builds, but is used to emulate global directories in the tests
if [[ $VERSION = 'v1.2.3-dev' ]]; then
    BIN_TEST_ROOT=${BIN_TEST_ROOT-}
else
    BIN_TEST_ROOT='' # kcov-ignore-line: Not tested
fi

# ANSI codes
if [[ -t 1 ]]; then
    # kcov-ignore-start: There is never a terminal connected during unit tests
    RESET=$'\e[0m'
    BOLD=$'\e[1m'
    UNDERLINE=$'\e[4m'
    YELLOW=$'\e[33m'
    GREY=$'\e[90m'
    LWHITE=$'\e[97m'
    # kcov-ignore-end
else
    RESET=''
    BOLD=''
    UNDERLINE=''
    YELLOW=''
    GREY=''
    LWHITE=''
fi

# The debug output always goes to a terminal, but indirectly
DEBUG_GREY=$'\e[90m'
DEBUG_RESET=$'\e[0m'

# Exit codes
ERR_NOT_EXECUTABLE=126
ERR_NOT_FOUND=127
ERR_GENERIC=246

# Other constants
NEW_LINE=$'\n'

#endregion =====================================================================
#region ==== OUTPUT / DEBUGGING ================================================

write_debug_to_fd3=false

# If FD3 is open, write debug data to it (used in the test script)
if { true >&3; } 2>/dev/null; then # kcov-ignore-line: Usage not detected
    write_debug_to_fd3=true
fi

# So we can use 'debug' inside functions where stdout is redirected,
# redirect FD4 to stdout globally, then write debug data to FD4 locally
exec 4>&1

debug() {
    # kcov-ignore-start: Debug statements are only added when needed
    # (Originally I had it output debug logs all the time, but as the script
    # grew they got harder to maintain and harder to read)

    if ! $write_debug_to_fd3; then
        return
    fi

    local lines
    lines="${BASH_LINENO[*]}"
    lines=${lines% 0}
    echo "$@" "${DEBUG_GREY}[line ${lines// /, }]${DEBUG_RESET}" >&3
    # kcov-ignore-end
}

fail() {
    local code message

    message=$1
    code=${2-$ERR_GENERIC}

    if [[ $action = 'complete-bash' ]]; then
        exit
    fi

    echo "$exe: $message" >&2
    exit "$code"
}

bug() {
    # kcov-ignore-start: This should never be needed!
    local lines

    lines="${BASH_LINENO[*]}"
    lines=${lines% 0}

    fail "BUG: $1 on line ${lines// /, }"
    # kcov-ignore-end
}

#endregion =====================================================================
#region ==== PARSE PARAMETERS ==================================================

action='' # complete-bash, completion, create, edit, help, version
dir=''
exact=''
exe=${0##*/}
error=''
fallback=''
shim=false

help() {
    echo "Usage: bin [OPTIONS] [--] [COMMAND] [ARGUMENTS...]"
    echo
    echo "Options that can be used with a command:"
    echo "  --dir DIR             Specify the directory name to search for (overrides .binconfig)"
    echo "  --exact               Disable unique prefix matching"
    echo "  --exe NAME            Override the executable name displayed in the command list"
    echo "  --fallback COMMAND    If the command is not found, run the given global command (implies '--exact')"
    echo "  --prefix              Enable unique prefix matching (overrides .binconfig)"
    echo "  --shim                If the command is not found, run the global command with the same name (implies '--exact')"
    echo
    echo "Options that do something with a COMMAND:"
    echo "  --create, -c          Create the given script and open in your \$EDITOR (implies '--exact')"
    echo "  --edit, -e            Open the given script in your \$EDITOR"
    echo
    echo "Options that do something special and don't accept a COMMAND:"
    echo "  --completion          Output a tab completion script for the current shell"
    echo "  --help, -h            Display this help"
    echo "  --version, -v         Display the current version number and exit"
    echo
    echo "Any options must be given before the command, because everything after the command will be passed as parameters to the script."
    echo
    echo "For more details see https://github.com/bin-cli/bin-cli#readme"
}

set_action() {
    if [[ -n $action ]]; then
        set_error "The '--$action' and '--$1' arguments are incompatible"
    fi

    action=$1
}

set_error() {
    # Don't exit immediately because '--exe' may come after the parameter with the error
    # But only display the first error encountered, as if we had exited immediately
    if [[ -z $error ]]; then
        error=$1
    fi
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --complete-bash)
            set_action complete-bash
            shift
            ;;
        --completion)
            set_action completion
            shift
            ;;
        --create | -c)
            set_action create
            shift
            ;;
        --dir)
            dir=$2
            shift 2
            ;;
        --dir=*)
            dir=${1#*=}
            shift
            ;;
        --edit | -e)
            set_action edit
            shift
            ;;
        --exact)
            exact=true
            shift
            ;;
        --exe)
            exe=$2
            shift 2
            ;;
        --exe=*)
            exe=${1#*=}
            shift
            ;;
        --fallback)
            fallback=$2
            shift 2
            ;;
        --fallback=*)
            fallback=${1#*=}
            shift
            ;;
        --help | -h)
            set_action help
            shift
            ;;
        --prefix)
            exact=false
            shift
            ;;
        --shim)
            shim=true
            shift
            ;;
        --version | -v)
            set_action version
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            fail "Invalid option '$1'"
            ;;
        *)
            break
            ;;
    esac
done

if [[ -n $error ]]; then
    fail "$error"
fi

if [[ -z $action ]]; then
    action='run'
fi

#endregion =====================================================================
#region ==== DISPLAY HELP / VERSION INFORMATION ================================

if [[ $action = 'help' ]]; then
    help
    exit
fi

if [[ $action = 'version' ]]; then
    echo "Bin CLI $VERSION"
    exit
fi

#endregion =====================================================================
#region ==== TAB COMPLETION SCRIPT GENERATOR ===================================

# This doesn't do the tab completion - it just outputs the script to be 'eval'ed

if [[ $action = 'completion' ]]; then
    complete_command=("$BIN_EXECUTABLE" --complete-bash)
    if [[ -n $dir ]]; then
        complete_command+=("--dir" "'$dir'")
    fi
    if [[ $exe != 'bin' ]]; then
        complete_command+=("--exe" "'$exe'")
    fi
    echo "complete -C \"${complete_command[*]}\" -o default $exe"
    exit
fi

#endregion =====================================================================
#region ==== GENERIC HELPER FUNCTIONS ==========================================

in_array() {
    local needle value

    needle=$1
    shift

    for value in "$@"; do
        if [[ "$value" = "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

trim() {
    local string

    string=$1

    # https://stackoverflow.com/a/3352015/167815
    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"

    echo "$string"
}

#---------------------------------------
# Maps (associative arrays)
#---------------------------------------
# This is to support Bash 3 (macOS - *sigh*!), which doesn't have associative arrays

map_init() {
    local map

    map=$1

    eval "$map=()"
    eval "unset \"\${!map__${map}__@}\""
}

map_key() {
    local char i key length map

    map=$1
    key=$2

    printf '%s' "map__${map}__"

    length="${#key}"
    for ((i = 0; i < length; i++)); do
        char="${key:i:1}"
        case $char in
            [a-zA-Z0-9]) printf '%s' "$char" ;;
            # Encode all other characters in hex to make them valid variable names
            *) printf '_%02X' "'$char" ;;
        esac
    done
}

map_set() {
    local key map value

    map=$1
    key=$2
    value=$3

    # Make an array containing the raw keys so we can loop through them
    eval "$map+=(\"\$key\")"

    # Store the values in separate variables
    key=$(map_key "$map" "$key")
    printf -v "$key" %s "$value"
}

map_get() {
    local key map

    map=$1
    key=$2

    key=$(map_key "$map" "$key")

    if [[ -z ${!key+isset} ]]; then
        return 1
    fi

    echo "${!key}"
}

map_has() {
    local key map

    map=$1
    key=$2

    key=$(map_key "$map" "$key")

    [[ -n ${!key+isset} ]]
}

#---------------------------------------
# Filesystem
#---------------------------------------

findup() (
    while true; do
        if test "$@"; then
            echo "$PWD"
            return 0
        fi

        if [[ $PWD = '/' || $PWD = "$BIN_TEST_ROOT" ]]; then
            return 1
        fi

        cd ..

    done
)

relative_path() {
    local child parent

    parent=$1
    child=$2

    echo "${child#"${parent}/"}"
}

#---------------------------------------
# Cross-platform `realpath`
#---------------------------------------

# Based on: https://github.com/mkropat/sh-realpath/blob/65512368b8155b176b67122aa395ac580d9acc5b/realpath.sh
# Copyright (c) 2014 Michael Kropat - MIT License
# Modified to work with 'set -e', and to follow our code conventions

# Not every code path is covered by our tests
# kcov-ignore-start
realpath() {
    local resolved
    resolved=$(resolve_symlinks "$1")
    canonicalize_path "$resolved"
}

resolve_symlinks() {
    _resolve_symlinks "$1"
}

_resolve_symlinks() {
    _assert_no_path_cycles "$@" || return

    local dir_context new_context path

    if path=$(readlink -- "$1"); then
        dir_context=$(dirname -- "$1")
        new_context=$(_prepend_dir_context_if_necessary "$dir_context" "$path")
        _resolve_symlinks "$new_context" "$@"
    else
        echo "$1"
    fi
}

_prepend_dir_context_if_necessary() {
    if [[ $1 = '.' ]]; then
        echo "$2"
    else
        _prepend_path_if_relative "$1" "$2"
    fi
}

_prepend_path_if_relative() {
    case "$2" in
        /*) echo "$2" ;;
        *)  echo "$1/$2" ;;
    esac
}

_assert_no_path_cycles() {
    local target path

    target=$1
    shift

    for path in "$@"; do
        if [[ "$path" = "$target" ]]; then
            return 1
        fi
    done
}

canonicalize_path() {
    if [[ -d $1 ]]; then
        _canonicalize_dir_path "$1"
    else
        _canonicalize_file_path "$1"
    fi
}

_canonicalize_dir_path() {
    (cd "$1" 2>/dev/null && pwd -P)
}

_canonicalize_file_path() {
    local dir file
    dir=$(dirname -- "$1")
    file=$(basename -- "$1")

    (cd "$dir" 2>/dev/null && dir2=$(pwd -P) && echo "$dir2/$file")
}
# kcov-ignore-end

#endregion =====================================================================
#region ==== BIN FUNCTIONS =====================================================

#---------------------------------------
# Config files
#---------------------------------------

bin_dir_for() {
    local bin_dir_real file key line result root_real sanity_checks value

    file=$1
    sanity_checks=${2-false}

    line=0
    result=''
    while IFS='=' read -r key value; do
        ((line += 1))

        key=$(trim "$key")

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            break
        elif [[ $key = 'dir' ]]; then
            # dir=scripts
            value=$(trim "$value")
            result="${value%%/}"
            break
        fi
    done <"$file" # kcov-ignore-line: Usage not detected

    if [[ -z $result ]]; then
        result='bin'
        line=0
    fi

    if $sanity_checks; then
        if [[ $result = /* ]]; then
            fail "The option 'dir' cannot be an absolute path in $file line $line"
        fi

        if [[ -d "$root/$result" ]]; then
            bin_dir_real=$(realpath "$root/$result")
            root_real=$(realpath "$root")

            if [[ "$bin_dir_real/" != "$root_real/"* ]]; then
                fail "The option 'dir' cannot point to a directory outside $root in $file line $line"
            fi
        elif [[ $line -gt 0 ]]; then
            fail "The directory specified in $file line $line does not exist: $root/$result/"
        fi

        # It is not an error if (1) .binconfig exists, (2) 'dir' is not set and
        # (3) bin/ doesn't exist, because .binconfig may contain inline commands
    fi

    echo "$result"
}

#---------------------------------------
# Commands
#---------------------------------------

registered_commands=()
matching_commands=()

map_init command_to_executable
map_init command_to_inline_script
map_init executable_to_command
map_init original_commands

prevent_duplicate_command() {
    local name source type

    type=$1
    name=$2
    source=$3

    # This long-winded syntax (used here and in various other places) is to make
    # it work in Bash 3 (macOS) - https://stackoverflow.com/a/61551944/167815
    if in_array "$name" ${registered_commands+"${registered_commands[@]}"}; then
        fail "The $type '$name' defined in $source conflicts with an existing command"
    fi
}

register_executable_command() {
    local executable name

    name=$1
    executable=$2

    prevent_duplicate_command command "$name" "$executable"

    registered_commands+=("$name")
    map_set command_to_executable "$name" "$executable"
    map_set executable_to_command "$executable" "$name"
    map_set original_commands "$name" "$name"
}

register_inline_command() {
    local name script source

    name=$1
    script=$2
    source=$3

    prevent_duplicate_command command "$name" "$source"

    registered_commands+=("$name")
    map_set command_to_inline_script "$name" "$script"
    map_set original_commands "$name" "$name"
}

register_commands_in_directory() {
    local directory file name prefix realfile target

    directory=$1
    prefix=${2-}

    # Loop through the directory to find commands
    for file in "$directory/"*; do
        name=${file##*/}  # Remove path
        name=${name// /-} # Spaces to dashes

        realfile=$(realpath "$file") || true

        if [[ -L $file ]]; then
            target=$(readlink "$file")
            if [[ $target = /* ]]; then
                fail "The symlink '$file' must use a relative path, not absolute ('$target')"
            fi
            if [[ -e $file ]]; then
                register_executable_alias "$prefix$name" "$realfile" "$file"
            else
                broken_symlinks+=("$file => $target")
            fi
        elif [[ -d $file ]]; then
            # Ignore subdirectories if scripts are in the root directory,
            # because it could take a long time to search a large tree, and it's
            # unlikely someone who keeps scripts in the root would also have
            # some in subdirectories
            if ! $is_root_dir; then
                map_set executable_to_command "$realfile" "$prefix$name"
                register_commands_in_directory "$file" "$prefix$name "
            fi
        elif [[ ! -x $file ]]; then
            if ! $is_root_dir; then
                non_executable_files+=("$file")
            fi
        else
            # Ignore known plain text files if scripts are in the root directory,
            # mostly in case they're on a filesystem where all files are executable
            if ! ($is_root_dir && [[ $name =~ \.(json|md|txt|yaml|yml)$ ]]); then
                register_executable_command "$prefix$name" "$realfile"
            fi
        fi
    done
}

command_matches() {
    local command found target type

    type=$1
    target=$2
    command=$3

    # Check for a match of the given type
    found=false

    if [[ $type = exact ]]; then
        [[ "$command" = "$target" ]] && found=true
    elif [[ $type = with-extension ]]; then
        [[ "$command" = "$target".* ]] && found=true
    elif [[ $type = subcommands ]]; then
        [[ "$command" = "$target "* ]] && found=true
    elif [[ $type = prefix ]]; then
        [[ "$command" = "$target"* ]] && found=true
    else
        bug "Invalid \$type '$type' passed to command_matches()" # kcov-ignore-line: This should never be happen
    fi

    # If it doesn't match, return false
    if ! $found; then
        return 1
    fi

    return 0
}

is_hidden_command() {
    local command prefix_length target

    command=$1
    target=${2-}

    # We can't just match on $command, because it may be the parent command that
    # has already been typed that is hidden, so subcommands should be shown
    prefix_length=${#target}

    if [[ $prefix_length -eq 0 ]]; then
        command=" $command"
    else
        command="${command:$prefix_length}"
    fi

    [[ $command = *' _'* ]]
}

find_matching_commands() {
    local alias command target type

    type=$1
    target=$2
    stop_after_first=${3-false}

    map_init commands_matching_aliases

    for alias in ${aliases+"${aliases[@]}"}; do
        if command_matches "$type" "$target" "$alias"; then
            command=$(map_get original_commands "$alias")
            map_set commands_matching_aliases "$command" true
        fi
    done

    matching_commands=()
    for command in ${registered_commands+"${registered_commands[@]}"}; do
        if map_has commands_matching_aliases "$command"; then
            matching_commands+=("$command")
        elif command_matches "$type" "$target" "$command"; then
            matching_commands+=("$command")
        else
            continue
        fi

        if $stop_after_first; then
            break
        fi
    done
}

has_matching_commands() {
    local alias command target type

    type=$1
    target=$2

    find_matching_commands "$type" "$target" true

    [[ ${#matching_commands[@]} -gt 0 ]]
}

matching_commands_shared_prefix() {
    local command next_command prefix prefix_length remaining shared_next_command

    prefix=$1
    prefix_length=${#prefix}

    shared_next_command=''

    for command in ${matching_commands+"${matching_commands[@]}"}; do
        # Remove the common prefix
        remaining=${command:$prefix_length}

        if [[ ! $remaining = *' '* ]]; then
            continue
        fi

        next_command=${remaining/ */}

        if [[ -z $shared_next_command ]]; then
            shared_next_command=$next_command
        elif [[ "$next_command" != "$shared_next_command" ]]; then
            # Not unique
            return 1
        fi
    done

    if [[ -n $shared_next_command ]]; then
        echo "$prefix$shared_next_command"
    else
        # No subcommands found
        return 1
    fi
}

remove_extension() {
    local command

    # Can't use ${command%%.*} because it could remove too much ("a.b c" => "a" instead of "a.b")
    # Can't use ${command%.*} because it could remove too little ("a.b.c" => "a.b" instead of "a")
    command="$1"

    while [[ "$command" =~ (.*)(\.[a-zA-Z0-9]+)+ ]]; do
        command=${BASH_REMATCH[1]}
    done

    echo "$command"
}

has_duplicate() {
    local alias command long short

    short=$1
    long=$2

    for command in ${registered_commands+"${registered_commands[@]}"}; do
        case "$command" in
            # Ignore a match to itself
            "$long") continue ;;
            # Matched to the short command, but not the long one
            "$short") return 0 ;;
            "$short."*) return 0 ;;
            "$short "*) return 0 ;;
            *) continue ;;
        esac
    done

    for alias in ${aliases+"${aliases[@]}"}; do
        case "$alias" in
            "$short") return 0 ;;
            "$short "*) return 0 ;;
            *) continue ;;
        esac
    done

    # No matches found
    return 1
}

#---------------------------------------
# Aliases
#---------------------------------------

aliases=()

map_init alias_sources
map_init alias_to_executable

prevent_duplicate_alias() {
    local existing name source

    name=$1
    source=$2

    if existing=$(map_get alias_sources "$name"); then
        fail "The alias '$name' defined in $source conflicts with the alias defined in $existing"
    fi
}

register_command_alias() {
    local alias command source

    alias=$1
    command=$2
    source=$3

    prevent_duplicate_alias "$alias" "$source"

    aliases+=("$alias")
    map_set original_commands "$alias" "$command"
    map_set alias_sources "$alias" "$source"
}

register_executable_alias() {
    local alias executable source

    alias=$1
    executable=$2
    source=$3

    prevent_duplicate_alias "$alias" "$source"

    aliases+=("$alias")
    map_set alias_to_executable "$alias" "$executable"
    map_set alias_sources "$alias" "$source"
}

#---------------------------------------
# Run commands
#---------------------------------------

open_in_editor() {
    local editor file

    file=$1

    editor=${VISUAL-${EDITOR-}}

    if [[ -z $editor ]]; then
        if command -v editor &>/dev/null; then
            editor='editor'
        elif command -v nano &>/dev/null; then
            editor='nano'
        elif command -v vi &>/dev/null; then
            editor='vi'
        else
            fail 'No editor configured - please export EDITOR or VISUAL environment variables'
        fi
    fi

    exec "$editor" "$file"
}

run_command() {
    if [[ $action = 'complete-bash' ]]; then
        bug 'run_command() should not be reached during tab completion' # kcov-ignore-line: This should never be happen
    elif [[ $action = 'create' ]]; then
        fail "$1 already exists (use --edit to edit it)"
    elif [[ $action = 'edit' ]]; then
        open_in_editor "$1"
    else
        exec "$@"
    fi
}

run_command_if_only_one_match() {
    local command executable script

    if [[ ${#matching_commands[@]} -ne 1 ]]; then
        return
    fi

    command=${matching_commands[0]}

    # Export the command name so it can be displayed in help messages
    # Typically with a fallback to $0 if it is unset: ${BIN_COMMAND-$0}
    export BIN_COMMAND="$exe $command"

    # And this can be used to display other command names
    export BIN_EXE="$exe"

    if executable=$(map_get command_to_executable "$command"); then
        run_command "$executable" "$@"
    fi

    if script=$(map_get command_to_inline_script "$command"); then
        # These variables are useful for inline commands, but aren't made available
        # to regular commands because it is better to use "$(dirname "$0")" instead
        export BIN_ROOT="$root"
        export BIN_DIR="$bin_dir"

        run_command bash -c "$script" -- "$@"
    fi

    bug 'Reached the end of run_command_if_only_one_match() without running a command' # kcov-ignore-line: This should never be happen
}

#---------------------------------------
# Command help text
#---------------------------------------

map_init command_help

set_command_help() {
    local command help

    command=$1
    help=$2

    map_set command_help "$command" "$help"
}

get_command_help() {
    local command original_command

    command=$1

    original_command=$(map_get original_commands "$command")
    map_get command_help "$original_command"
}

#endregion =====================================================================
#region ==== FIND THE AVAILABLE COMMANDS, ALIASES, ETC. ========================

broken_symlinks=()
non_executable_files=()
commands_listed_in_config=()

#---------------------------------------
# Repeat while 'merge=true' is set
#---------------------------------------

error_if_not_found=true
keep_looking=true
main_binconfig=''
main_bin_dir=''
main_bin_dir_from_root=''
main_is_root_dir=false
main_root=''
merging=false
start_directory=$PWD
template='_TBC'

while $keep_looking; do

    keep_looking=false

    #---------------------------------------
    # Determine paths
    #---------------------------------------

    root=''
    binconfig=''
    bin_dir=''
    bin_dir_from_root=''
    is_root_dir=false

    if [[ -n $dir ]]; then

        # Look for the given directory
        if [[ $dir = /* ]]; then
            bin_dir=$dir

            if [[ ! -d $bin_dir ]]; then
                fail "Specified directory '$bin_dir/' is missing"
            fi
        else
            if ! dir_parent=$(cd "$start_directory" && findup -d "$dir"); then
                fail "Could not find '$dir/' directory starting from '$start_directory'" $ERR_NOT_FOUND
            fi

            bin_dir="$dir_parent/$dir"
        fi

        # If there is no .binconfig file, assume the parent directory is the root
        binconfig=''
        root=$(dirname "$bin_dir")
        bin_dir_from_root=$(basename "$bin_dir")

        # Look for a matching .binconfig file
        if binconfig_dir=$(cd "$bin_dir" && findup -f .binconfig); then
            binconfig_file="$binconfig_dir/.binconfig"
            dir_in_binconfig=$(bin_dir_for "$binconfig_file")
            required_dir=$(relative_path "$binconfig_dir" "$bin_dir")

            if [[ "$dir_in_binconfig" = "$required_dir" ]]; then
                binconfig=$binconfig_file
                root=$binconfig_dir
                bin_dir_from_root=$required_dir
            fi
        fi

    else

        if root=$(cd "$start_directory" && findup -f .binconfig); then
            binconfig="${root%/}/.binconfig"
            bin_dir_from_root=$(bin_dir_for "$binconfig" true)
            if [[ $bin_dir_from_root = '.' ]]; then
                bin_dir=${root%/}
            else
                bin_dir="${root%/}/$bin_dir_from_root"
            fi
        else
            if ! root=$(cd "$start_directory" && findup -d bin); then
                if ! $error_if_not_found; then
                    break
                elif $merging; then
                    # This returns a generic (i.e. configuration) error because merge=true should only be used if the parent exists
                    fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory' (merge=true)" $ERR_GENERIC
                else
                    # Whereas this returns a 'not found' error because it has probably just been run from a directory with no scripts
                    fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory'" $ERR_NOT_FOUND
                fi
            fi

            binconfig="${root%/}/.binconfig"
            bin_dir_from_root='bin'
            bin_dir="${root%/}/$bin_dir_from_root"

            if in_array "$bin_dir" "$BIN_TEST_ROOT/bin" "$BIN_TEST_ROOT/usr/bin" "$BIN_TEST_ROOT/usr/local/bin" "$BIN_TEST_ROOT/snap/bin" "$HOME/bin"; then
                if ! $error_if_not_found; then
                    break
                elif $merging; then
                    # This returns a generic (i.e. configuration) error because merge=true should only be used if the parent exists
                    fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory' (merge=true) (ignored '$bin_dir')" $ERR_GENERIC
                else
                    # Whereas this returns a 'not found' error because it has probably just been run from a directory with no scripts
                    fail "Could not find 'bin/' directory or '.binconfig' file starting from '$start_directory' (ignored '$bin_dir')" $ERR_NOT_FOUND
                fi
            fi
        fi

    fi

    # Special case for dir=.
    if [[ $bin_dir_from_root = '.' ]]; then
        is_root_dir=true
    fi

    #---------------------------------------
    # Find and register available commands
    #---------------------------------------

    if [[ -d $bin_dir ]]; then
        register_commands_in_directory "$bin_dir"
    fi

    #---------------------------------------
    # Parse config file
    #---------------------------------------

    if [[ -f $binconfig ]]; then
        command=''

        line=0
        while IFS='=' read -r key value; do
            ((line += 1))

            key=$(trim "$key")

            if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
                # Skip blank lines & comments
                :
            elif [[ $key =~ ^\[(.+)]$ ]]; then
                # [command]
                command=${BASH_REMATCH[1]}
                commands_listed_in_config+=("$command")
            elif [[ -z $command && $key = 'dir' ]]; then
                # Already handled (above)
                :
            elif [[ -z $command && $key = 'exact' ]]; then
                # exact = true
                # exact = false (default)
                if [[ -z $exact ]]; then
                    # Can't use ${value,,} because it doesn't work in Bash 3 (macOS)
                    value=$(trim "$value")
                    lc_value=$(echo "$value" | tr '[:upper:]' '[:lower:]')
                    if in_array "$lc_value" 'false' 'no' 'off' '0'; then
                        exact=false
                    elif in_array "$lc_value" 'true' 'yes' 'on' '1'; then
                        exact=true
                    else
                        fail "Invalid value for 'exact' in $binconfig line $line: $value"
                    fi
                fi
            elif [[ -z $command && $key = 'merge' ]]; then
                # merge = true
                # merge = optional
                # merge = false (default)
                value=$(trim "$value")
                lc_value=$(echo "$value" | tr '[:upper:]' '[:lower:]')
                if in_array "$lc_value" 'false' 'no' 'off' '0'; then
                    keep_looking=false
                elif in_array "$lc_value" 'true' 'yes' 'on' '1'; then
                    keep_looking=true
                    error_if_not_found=true
                elif [[ $lc_value = 'optional' ]]; then
                    keep_looking=true
                    error_if_not_found=false
                else
                    fail "Invalid value for 'merge' in $binconfig line $line: $value"
                fi
            elif [[ -z $command && $key = 'template' ]]; then
                if [[ $template = '_TBC' ]]; then
                    template=$(trim "$value")
                fi
            elif [[ -z $command ]]; then
                # Unknown keys don't trigger an error for forwards compatibility (global)
                debug "Ignored unknown key '$key' in $binconfig line $line"
            elif [[ ($key = 'alias' || $key = 'aliases') ]]; then
                # alias = blah
                # aliases = blah1, blah2
                IFS=',' read -ra line_aliases <<<"$value"
                for alias in ${line_aliases+"${line_aliases[@]}"}; do
                    alias=$(trim "$alias")
                    register_command_alias "$alias" "$command" "$binconfig line $line"
                done
            elif [[ $key = 'command' ]]; then
                # command = echo 'Hello, World!'
                value=$(trim "$value")
                register_inline_command "$command" "$value" "$binconfig line $line"
            elif [[ $key = 'help' ]]; then
                # help=Description
                value=$(trim "$value")
                if [[ -n "$value" ]]; then
                    set_command_help "$command" "$value"
                fi
            else
                # Unknown keys don't trigger an error for forwards compatibility (command)
                debug "Ignored unknown key '$key' in $binconfig line $line"
            fi
        done <"$binconfig" # kcov-ignore-line: Usage not detected
    fi

    # Default values, if not given at the command line or in the config file
    if [[ -z $exact ]]; then
        exact=false
    fi

    #---------------------------------------
    # Process aliases
    #---------------------------------------

    for alias in ${alias_to_executable+"${alias_to_executable[@]}"}; do
        if executable=$(map_get alias_to_executable "$alias"); then
            command=$(map_get executable_to_command "$executable")
            map_set original_commands "$alias" "$command"
        fi
    done

    for alias in ${aliases+"${aliases[@]}"}; do
        # Check for conflicts
        source=$(map_get alias_sources "$alias")
        prevent_duplicate_command alias "$alias" "$source"

        # Expand aliases to cover subcommands (e.g. if 'deploy'='push' then 'deploy live'='push live')
        target=$(map_get original_commands "$alias")
        for command in ${registered_commands+"${registered_commands[@]}"}; do
            if [[ "$command" = "$target "* ]]; then
                suffix=${command:${#target}}
                aliases+=("$alias$suffix")
                map_set original_commands "$alias$suffix" "$target$suffix"
            fi
        done
    done

    #---------------------------------------
    # Remember the lowest level for --create
    #---------------------------------------

    if [[ -z $main_root ]]; then
        main_binconfig=$binconfig
        main_bin_dir=$bin_dir
        main_bin_dir_from_root=$bin_dir_from_root
        main_is_root_dir=$is_root_dir
        main_root=$root
    fi

    #---------------------------------------
    # Merge with parent?
    #---------------------------------------

    if $keep_looking; then
        merging=true
        start_directory=$(dirname "$root")
        dir=''
    fi

done

#endregion =====================================================================
#region ==== TAB COMPLETION SETUP ==============================================

last_parameter=0

if [[ $action = 'complete-bash' ]]; then
    # Remove everything after the cursor, and assign everything before it to $1, $2, etc.
    args=${COMP_LINE:0:$COMP_POINT}
    # shellcheck disable=SC2086
    set -- $args

    # Remove the command name
    shift

    # If there is a space at the end, we want to complete the next parameter; otherwise the last one given
    if [[ $args != *' ' ]]; then
        last_parameter=1
    fi
fi

#endregion =====================================================================
#region ==== PARSE PARAMETERS AND RUN THE COMMAND ==============================

# If no command is given, we will list all available commands
list_title='Available commands'
list_commands=(${registered_commands+"${registered_commands[@]}"})

# Loop through each argument until we find a matching command
current_directory=$main_bin_dir
full_command=''

while [[ $# -gt $last_parameter ]]; do
    subcommand=$1
    shift

    # Special case for creating/editing the .binconfig file
    if [[ -z $full_command && $subcommand = '.binconfig' ]]; then
        if [[ $action = 'create' ]]; then
            if [[ -e "$main_root/.binconfig" ]]; then
                fail "$main_root/.binconfig already exists (use --edit to edit it)"
            fi

            ( # kcov-ignore-line: Usage not detected
                output_started=false

                if [[ $main_bin_dir_from_root != 'bin' ]]; then
                    echo "dir = $main_bin_dir_from_root"
                    output_started=true
                fi

                for command in ${registered_commands+"${registered_commands[@]}"}; do
                    if $output_started; then
                        echo
                    fi
                    echo "[$command]"
                    echo 'alias ='
                    echo 'help ='
                    output_started=true
                done

                if ! $output_started; then
                    echo
                fi
            ) > "$main_root/.binconfig" # kcov-ignore-line: Usage not detected

            echo "Created file $main_root/.binconfig"
            open_in_editor "$main_root/.binconfig"
        elif [[ $action = 'edit' ]]; then
            if [[ ! -e "$main_root/.binconfig" ]]; then
                fail 'No .binconfig file found (use --create to create one)'
            fi

            bin_dir_for_binconfig=$(bin_dir_for "$main_root/.binconfig")
            if [[ "$bin_dir_for_binconfig" != "$main_bin_dir_from_root" ]]; then
                fail ".binconfig belongs to $bin_dir_for_binconfig/ not $main_bin_dir_from_root/"
            fi

            open_in_editor "$main_root/.binconfig"
        fi
    fi

    # Build up the entered command in canonical format
    full_command+=" $subcommand"

    # Check if there's an exact match - run it if so
    find_matching_commands exact "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there's an almost-exact match with an added extension - run it if so
    find_matching_commands with-extension "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there are any subcommands - move on to the next argument if so
    find_matching_commands subcommands "${full_command:1}"

    if [[ ${#matching_commands[@]} -gt 0 ]]; then
        current_directory="$current_directory/$subcommand"
        list_title='Available subcommands'
        list_commands=(${matching_commands+"${matching_commands[@]}"})
        continue
    fi

    # No exact matches - check for special actions
    if [[ $action = 'create' ]]; then
        if [[ $subcommand = .* ]]; then
            fail "Command names may not start with '.'"
        fi

        if [[ $# -gt 0 ]]; then
            current_directory="$current_directory/$subcommand"
            continue
        fi

        mkdir -p "$current_directory"
        script="$current_directory/$subcommand"
        if [[ $template = '_TBC' ]]; then
            # Using '_TBC' as the placeholder allows the user to set it to a blank string
            # in the config file. We can't just initialise it to the following value
            # because we want the first (lowest) .binconfig file to take precedence.
            template='#!/usr/bin/env bash\nset -euo pipefail\n\n'
        fi
        echo -e "$template" > "$script"
        chmod +x "$script"
        echo "Created script $script"
        open_in_editor "$script"
    elif $shim; then
        # We want word splitting here
        # shellcheck disable=SC2086
        run_command ${full_command:1} "$@"
    elif [[ -n $fallback ]]; then
        # We want word splitting here - the fallback command may contain spaces to separate arguments
        # shellcheck disable=SC2086
        run_command $fallback "$@"
    fi

    # Check if there are any prefix matches
    # We need to check even with --exact so we can list them
    find_matching_commands prefix "${full_command:1}"

    if ! $exact && parent=$(matching_commands_shared_prefix "${full_command:1}"); then
        # If all matching commands have the same parent command, pretend
        # the user typed the full parent command, then continue parsing
        current_directory="$current_directory/$parent"
        full_command=" $parent"
        list_title='Matching commands'
        list_commands=(${matching_commands+"${matching_commands[@]}"})
        continue
    fi

    if ! $exact; then
        run_command_if_only_one_match "$@"
    fi

    # If there were no prefix matches, stop searching
    if [[ ${#matching_commands[@]} -eq 0 ]]; then
        if $main_is_root_dir && [[ -d "$current_directory/$subcommand" ]]; then
            fail "Subcommands are not supported with the config option 'dir = $main_bin_dir_from_root'"
        fi
        if [[ $subcommand = .* && -e "$current_directory/$subcommand" ]]; then
            fail "Command names may not start with '.'"
        fi
        if [[ -f "$current_directory/$subcommand" && ! -x "$current_directory/$subcommand" ]]; then
            fail "'$current_directory/$subcommand' is not executable (chmod +x)" $ERR_NOT_EXECUTABLE
        fi

        append=''
        if in_array "${full_command:1}" completion create edit help version; then
            append="${NEW_LINE}${GREY}Perhaps you meant to run 'bin --${full_command:1}'?${RESET}"
        fi
        fail "Command '${full_command:1}' not found in $main_bin_dir/ or $main_binconfig$append" $ERR_NOT_FOUND
    fi

    # Otherwise display the list of matches
    list_title='Matching commands'
    list_commands=(${matching_commands+"${matching_commands[@]}"})
    break
done

#endregion =====================================================================
#region ==== DETERMINE SHORTENED COMMAND NAMES & ALIASES =======================

# Commands
shortened_commands=()

for command in ${list_commands+"${list_commands[@]}"}; do
    short=$(remove_extension "$command")

    if [[ "$short" = "$command" ]]; then
        shortened_commands+=("$command")
    elif has_duplicate "$short" "$command"; then
        shortened_commands+=("$command")
    else
        shortened_commands+=("$short")
        original_command=$(map_get original_commands "$command")
        map_set original_commands "$short" "$original_command"
    fi
done

# Aliases
shortened_aliases=()

for alias in ${aliases+"${aliases[@]}"}; do
    short=$(remove_extension "$alias")

    if [[ "$short" = "$alias" ]]; then
        shortened_aliases+=("$alias")
    elif has_duplicate "$short" "$alias"; then
        shortened_aliases+=("$alias")
    else
        shortened_aliases+=("$short")
        original_command=$(map_get original_commands "$alias")
        map_set original_commands "$short" "$original_command"
    fi
done

#endregion =====================================================================
#region ==== TAB COMPLETION OUTPUT =============================================

if [[ $action = 'complete-bash' ]]; then

    # Work out the full prefix we're looking for
    prefix=''
    if [[ -n $full_command ]]; then
        prefix="${full_command:1} "
    fi

    target="$prefix${1-}"

    # Look for commands and aliases that match, and collect the first parameter for each
    matches=()
    matching_commands=()

    for command in ${shortened_commands+"${shortened_commands[@]}"}; do
        if ! command_matches prefix "$target" "$command"; then
            continue
        fi

        match=${command#"$prefix"}
        match=${match/ */}
        matches+=("$match")
        matching_commands+=("$command")
    done

    for alias in ${shortened_aliases+"${shortened_aliases[@]}"}; do
        if ! command_matches prefix "$target" "$alias"; then
            continue
        fi

        command=$(map_get original_commands "$alias")
        if ! in_array "$command" ${matching_commands+"${matching_commands[@]}"}; then
            match=${alias#"$prefix"}
            match=${match/ */}
            matches+=("$match")
            matching_commands+=("$command")
        fi
    done

    # Output the matches and remove duplicates
    for command in ${matches+"${matches[@]}"}; do
        if is_hidden_command "$command" "${1-}"; then
            continue
        fi

        echo "$command"
    done | sort | uniq

    exit

fi

#endregion =====================================================================
#region ==== LIST AVAILABLE/MATCHING COMMANDS ==================================

# Remove hidden commands
visible_commands=()

for command in ${shortened_commands+"${shortened_commands[@]}"}; do
    if ! is_hidden_command "$command" "${full_command:1}"; then
        visible_commands+=("$command")
    fi
done

# Calculate the maximum length of a command in the list so we can align the help text
maxlength=0
for command in ${visible_commands+"${visible_commands[@]}"}; do
    if [[ ${#command} -gt $maxlength ]]; then
        maxlength=${#command}
    fi
done

# Output the list
get_command_aliases() {
    local alias command command_alias_count command_aliases original_command target

    command=$1

    command_alias_count=0
    command_aliases=''

    original_command=$(map_get original_commands "$command")

    for alias in ${shortened_aliases+"${shortened_aliases[@]}"}; do
        target=$(map_get original_commands "$alias")
        if [[ "$target" = "$original_command" ]]; then
            ((command_alias_count += 1))
            command_aliases+=", $alias"
        fi
    done

    if [[ $command_alias_count -eq 1 ]]; then
        echo "alias: ${command_aliases:2}"
    elif [[ $command_alias_count -gt 1 ]]; then
        echo "aliases: ${command_aliases:2}"
    else
        return 1
    fi
}

echo "$LWHITE$BOLD$UNDERLINE$list_title$RESET"

for command in ${visible_commands+"${visible_commands[@]}"}; do
    if command_help=$(get_command_help "$command"); then
        if command_aliases=$(get_command_aliases "$command"); then
            printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help $GREY($command_aliases)$RESET"
        else
            printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help"
        fi
    else
        if command_aliases=$(get_command_aliases "$command"); then
            printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$GREY($command_aliases)$RESET"
        else
            printf "%s %s\n" "$exe" "$command"
        fi
    fi
done | sort

if [[ ${#visible_commands[@]} -eq 0 ]]; then
    echo "${GREY}None found${RESET}"
fi

#endregion =====================================================================
#region ==== DISPLAY WARNINGS ==================================================

# Broken symlinks
if [[ ${#broken_symlinks[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following symlinks point to targets that don't exist:${RESET}"
    for symlink in ${broken_symlinks+"${broken_symlinks[@]}"}; do
        echo "$symlink"
    done
fi

# Non-executable files
if [[ ${#non_executable_files[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following files are not executable (chmod +x):${RESET}"
    for file in ${non_executable_files+"${non_executable_files[@]}"}; do
        echo "$file"
    done
fi

# Missing commands in .binconfig
missing_commands=()
for command in ${commands_listed_in_config+"${commands_listed_in_config[@]}"}; do

    # Regular script
    if map_has command_to_executable "$command"; then
        continue
    fi

    # Inline command
    if map_has command_to_inline_script "$command"; then
        continue
    fi

    # Directory
    if has_matching_commands subcommands "$command"; then
        continue
    fi

    missing_commands+=("$command")
done

if [[ ${#missing_commands[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following commands listed in .binconfig do not exist:${RESET}"
    for command in ${missing_commands+"${missing_commands[@]}"}; do
        echo "[$command]"
    done
fi

#endregion =====================================================================
