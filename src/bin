#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail
shopt -s nullglob

################################################################################
# Bin - A simple task runner           Copyright (c) 2023 Dave James Miller    #
# https://github.com/bin-cli/bin-cli   MIT License                             #
################################################################################

#===============================================================================
# Constants
#===============================================================================

# Version (set by build script - don't change in source file)
VERSION='v1.2.3-source'

# Executable
BIN_EXECUTABLE="$0"

# The BIN_TEST_ROOT env var is ignored in production builds, but is used to emulate global directories in the tests
if [[ $VERSION = 'v1.2.3-dev' ]]; then
    BIN_TEST_ROOT=${BIN_TEST_ROOT-}
else
    BIN_TEST_ROOT='' # kcov-ignore-line: Not tested
fi

# ANSI codes
if [[ -t 1 ]]; then
    # kcov-ignore-start: There is never a terminal connected during unit tests
    RESET=$'\e[0m'
    BOLD=$'\e[1m'
    UNDERLINE=$'\e[4m'
    YELLOW=$'\e[33m'
    GREY=$'\e[90m'
    LWHITE=$'\e[97m'
    # kcov-ignore-end
else
    RESET=''
    BOLD=''
    UNDERLINE=''
    YELLOW=''
    GREY=''
    LWHITE=''
fi

# The debug output always goes to a terminal, but indirectly
DEBUG_GREY=$'\e[90m'
DEBUG_RESET=$'\e[0m'

# Exit codes
ERR_NOT_EXECUTABLE=126
ERR_NOT_FOUND=127
ERR_GENERIC=246

#===============================================================================
# Cross-platform `realpath`
#===============================================================================

# Source: https://github.com/mkropat/sh-realpath/blob/65512368b8155b176b67122aa395ac580d9acc5b/realpath.sh

# kcov-ignore-start: Not our code to test, and not every code path is covered by our tests
realpath() {
    canonicalize_path "$(resolve_symlinks "$1")"
}

resolve_symlinks() {
    _resolve_symlinks "$1"
}

_resolve_symlinks() {
    _assert_no_path_cycles "$@" || return

    local dir_context path
    path=$(readlink -- "$1")
    # shellcheck disable=SC2181
    if [ $? -eq 0 ]; then
        dir_context=$(dirname -- "$1")
        _resolve_symlinks "$(_prepend_dir_context_if_necessary "$dir_context" "$path")" "$@"
    else
        printf '%s\n' "$1"
    fi
}

_prepend_dir_context_if_necessary() {
    if [ "$1" = . ]; then
        printf '%s\n' "$2"
    else
        _prepend_path_if_relative "$1" "$2"
    fi
}

_prepend_path_if_relative() {
    case "$2" in
        /* ) printf '%s\n' "$2" ;;
         * ) printf '%s\n' "$1/$2" ;;
    esac
}

_assert_no_path_cycles() {
    local target path

    target=$1
    shift

    for path in "$@"; do
        if [ "$path" = "$target" ]; then
            return 1
        fi
    done
}

canonicalize_path() {
    if [ -d "$1" ]; then
        _canonicalize_dir_path "$1"
    else
        _canonicalize_file_path "$1"
    fi
}

_canonicalize_dir_path() {
    (cd "$1" 2>/dev/null && pwd -P)
}

_canonicalize_file_path() {
    local dir file
    dir=$(dirname -- "$1")
    file=$(basename -- "$1")
    (cd "$dir" 2>/dev/null && printf '%s/%s\n' "$(pwd -P)" "$file")
}
# kcov-ignore-end

#===============================================================================
# Helpers
#===============================================================================

#---------------------------------------
# General
#---------------------------------------

in_array() {
    local needle=$1
    shift

    local value

    for value in "$@"; do
        if [[ "$value" = "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

#---------------------------------------
# Maps (associative arrays)
#---------------------------------------
# This is to support Bash 3 (macOS - *sigh*!), which doesn't have associative arrays

map_key() {
    local key=$1

    local i
    local length="${#key}"
    for ((i = 0; i < length; i++)); do
        local char="${key:i:1}"
        case $char in
            [a-zA-Z0-9]) printf '%s' "$char" ;;
            # Encode all other characters in hex to make them valid variable names
            *) printf '_%02X' "'$char" ;;
        esac
    done
}

map_set() {
    local name=$1
    local key=$2
    local value=$3

    # Make an array containing the raw keys
    eval "$name+=(\"\$key\")"

    # Store the values in separate variables
    printf -v "map__${name}__$(map_key "$2")" %s "$value"
}

map_get() {
    local name=$1
    local key=$2
    local default=${3-}

    key="map__${name}__$(map_key "$key")"

    echo "${!key-$default}"
}

map_clear() {
    local name=$1

    eval "unset \"\${!map__${name}__@}\""
    eval "$name=()"
}

#---------------------------------------
# Output
#---------------------------------------

# So we can use 'debug' inside functions where stdout is redirected,
# redirect FD4 to stdout globally, then write debug data to FD4 locally
exec 4>&1

# If FD3 is open, write debug data to it
fd3_open=false
if { true >&3; } 2>/dev/null; then # kcov-ignore-line: Usage not detected
    fd3_open=true
fi

debug() {
    # Display debug data when using --debug (only after parsing parameters)
    if ${debug-false}; then
        echo "$@" >&4
    fi

    # Output debug data to FD 3 when using the 'bin tdd' script in development
    if $fd3_open; then
        local lines="${BASH_LINENO[*]}"
        lines=${lines% 0}
        echo "$@" "${DEBUG_GREY}[line ${lines// /, }]${DEBUG_RESET}" >&3
    fi
}

debug_exit() {
    debug "$@"
    if ${debug-false}; then
        exit
    fi
}

fail() {
    local message=$1
    local code=${2-$ERR_GENERIC}

    debug "Failed with message: $message"
    debug_exit "Exit code: $code"

    if [[ $action = 'complete-bash' ]]; then
        exit
    fi

    echo "$exe: $message" >&2
    exit "$code"
}

bug() {
    # kcov-ignore-start: This should never be needed!
    local lines="${BASH_LINENO[*]}"
    lines=${lines% 0}
    fail "BUG: $1 on line ${lines// /, }"
    # kcov-ignore-end
}

#---------------------------------------
# Filesystem
#---------------------------------------

findup() (
    while true; do
        if test "$@"; then
            debug "---- Checking in $PWD - found"
            echo "$PWD"
            return 0
        else
            debug "---- Checking in $PWD - not found"
        fi

        if [[ $PWD = '/' || $PWD = "$BIN_TEST_ROOT" ]]; then
            return 1
        fi

        cd ..

    done
)

relative_path() {
    local parent=$1
    local child=$2

    echo "${child#"${parent}/"}"
}

#---------------------------------------
# Config files
#---------------------------------------

bin_dir_for() {
    local file=$1
    local sanity_checks=${2-false}

    debug "-- Checking $binconfig for a 'dir' setting"

    local line=0
    local result=''
    while IFS='=' read -r key value; do
        ((line += 1))

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            debug "---- Reached section $key - giving up"
            break
        elif [[ $key = 'dir' ]]; then
            # dir=scripts
            debug "---- Found $key=$value"
            result=$value
            break
        fi
    done <"$file" # kcov-ignore-line: Usage not detected

    if [[ -z $result ]]; then
        debug "---- Not found (defaulting to 'bin')"
        result='bin'
    fi

    if $sanity_checks; then
        if [[ $result = /* ]]; then
            fail "The option 'dir' cannot be an absolute path in $file line $line"
        fi

        # shellcheck disable=SC2155
        local bin_dir_real=$(realpath "$root/$result") || true
        # shellcheck disable=SC2155
        local root_real=$(realpath "$root") || true

        if [[ "$bin_dir_real/" != "$root_real/"* ]]; then
            debug "---- bin_dir_real=$bin_dir_real"
            debug "---- root_real=$root_real"
            fail "The option 'dir' cannot point to a directory outside $root in $file line $line"
        fi
    fi

    echo "${result%%/}"
}

#---------------------------------------
# Commands
#---------------------------------------

commands=()
matching_commands=()

prevent_duplicate_command() {
    local type=$1
    local name=$2
    local source=$3

    # This long-winded syntax (used here and in various other places) is to make
    # it work in Bash 3 (macOS) - https://stackoverflow.com/a/61551944/167815
    if in_array "$name" ${commands+"${commands[@]}"}; then
        fail "The $type '$name' defined in $source conflicts with an existing command"
    fi
}

register_executable_command() {
    local name=$1
    local executable=$2

    prevent_duplicate_command command "$name" "$executable"

    commands+=("$name")
    map_set command_to_executable "$name" "$executable"
    map_set executable_to_command "$executable" "$name"
    debug "-- Registered command '$name' for executable '$executable'"
}

register_inline_command() {
    local name=$1
    local script=$2
    local source=$3

    prevent_duplicate_command command "$name" "$source"

    commands+=("$name")
    map_set command_to_inline_script "$name" "$script"
    debug "-- Registered inline command '$name' for script '$script'"
}

command_matches() {
    local type=$1
    local target=$2
    local command=$3

    # Check for a match of the given type
    if [[ $type = exact ]]; then
        [[ "$command" = "$target" ]]
    elif [[ $type = with-extension ]]; then
        [[ "$command" = "$target".* ]]
    elif [[ $type = subcommands ]]; then
        [[ "$command" = "$target "* ]]
    elif [[ $type = prefix ]]; then
        [[ "$command" = "$target"* ]]
    else
        bug "Invalid \$type '$type' passed to command_matches()" # kcov-ignore-line: This should never be happen
    fi

    # If it doesn't match, return false
    # shellcheck disable=SC2181
    if [[ $? -gt 0 ]]; then
        debug "---- No match for '$command'"
        return 1
    fi

    return 0
}

is_hidden_command() {
    local command=$1
    local target=${2-}

    # We can't just match on $command, because it may be the parent command that
    # has already been typed that is hidden, so subcommands should be shown
    local prefix_length=${#target}

    if [[ $prefix_length -eq 0 ]]; then
        command=" $command"
    else
        command="${command:$prefix_length}"
    fi

    [[ $command = *' _'* ]]
}

find_matching_commands() {
    local type=$1
    local target=$2
    local command
    local alias

    debug "-- Looking for command '$target' ($type)"

    map_clear commands_matching_aliases

    for alias in ${aliases+"${aliases[@]}"}; do
        if command_matches "$type" "$target" "$alias"; then
            command=$(map_get alias_to_command "$alias")
            map_set commands_matching_aliases "$command" true
            debug "---- Found matching alias '$alias' for command '$command'"
        fi
    done

    matching_commands=()
    for command in ${commands+"${commands[@]}"}; do
        # shellcheck disable=SC2091
        if $(map_get commands_matching_aliases "$command" false); then
            debug "---- Found matching command '$command' (from alias)"
            matching_commands+=("$command")
        elif command_matches "$type" "$target" "$command"; then
            debug "---- Found matching command '$command'"
            matching_commands+=("$command")
        fi
    done
}

matching_commands_shared_prefix() {
    local prefix=$1
    local prefix_length=${#prefix}

    local shared_next_command=''

    local command
    for command in ${matching_commands+"${matching_commands[@]}"}; do
        # Remove the common prefix
        local remaining=${command:$prefix_length}

        if [[ ! $remaining = *' '* ]]; then
            continue
        fi

        local next_command=${remaining/ */}

        if [[ -z $shared_next_command ]]; then
            shared_next_command=$next_command
        elif [[ "$next_command" != "$shared_next_command" ]]; then
            # Not unique
            return 1
        fi
    done

    if [[ -n $shared_next_command ]]; then
        echo "$prefix$shared_next_command"
    else
        # No subcommands found
        return 1
    fi
}

remove_extension() {
    # Can't use ${command%%.*} because it could remove too much ("a.b c" => "a" instead of "a.b")
    # Can't use ${command%.*} because it could remove too little ("a.b.c" => "a.b" instead of "a")
    local command="$1"

    while [[ "$command" =~ (.*)(\.[a-zA-Z0-9]+)+ ]]; do
        command=${BASH_REMATCH[1]}
    done

    echo "$command"
}

has_duplicate() {
    local short=$1
    local long=$2

    local command
    for command in ${commands+"${commands[@]}"}; do
        case "$command" in
            # Ignore a match to itself
            "$long") continue ;;
            # Matched to the short command, but not the long one
            "$short") return 0 ;;
            "$short."*) return 0 ;;
            "$short "*) return 0 ;;
        esac
    done

    local alias
    for alias in ${aliases+"${aliases[@]}"}; do
        case "$alias" in
            "$short") return 0 ;;
            "$short "*) return 0 ;;
        esac
    done

    # No matches found
    return 1
}

#---------------------------------------
# Aliases
#---------------------------------------

aliases=()
alias_to_executable=()

prevent_duplicate_alias() {
    local name=$1
    local source=$2

    if [[ -n $(map_get alias_sources "$name") ]]; then
        fail "The alias '$name' defined in $source conflicts with the alias defined in $(map_get alias_sources "$name")"
    fi
}

register_command_alias() {
    local alias=$1
    local command=$2
    local source=$3

    prevent_duplicate_alias "$alias" "$source"

    aliases+=("$alias")
    map_set alias_to_command "$alias" "$command"
    map_set alias_sources "$alias" "$source"

    debug "---- Registered alias '$alias' for command '$command'"
}

register_executable_alias() {
    local alias=$1
    local executable=$2
    local source=$3

    prevent_duplicate_alias "$alias" "$source"

    aliases+=("$alias")
    map_set alias_to_executable "$alias" "$executable"
    map_set alias_sources "$alias" "$source"

    debug "-- Registered alias '$alias' for executable '$executable'"
}

#---------------------------------------
# Run commands
#---------------------------------------

open_in_editor() {
    local file=$1

    local editor=${VISUAL-${EDITOR-}}

    if [[ -z $editor ]]; then
        if command -v editor &>/dev/null; then
            editor='editor'
        elif command -v nano &>/dev/null; then
            editor='nano'
        elif command -v vi &>/dev/null; then
            editor='vi'
        else
            fail 'No editor configured - please export EDITOR or VISUAL environment variables'
        fi
    fi

    debug_exit "Would execute:" "$editor" "$file"
    exec "$editor" "$file"
}

run_command() {
    if [[ $action = 'complete-bash' ]]; then
        bug 'run_command() should not be reached during tab completion' # kcov-ignore-line: This should never be happen
    elif [[ $action = 'create' ]]; then
        fail "$1 already exists (use --edit to edit it)"
    elif [[ $action = 'edit' ]]; then
        open_in_editor "$1"
    elif [[ $action = 'print' ]]; then
        debug_exit "Would print:" "$@"
        echo "$@"
        exit
    else
        debug_exit "Would execute:" "$@"
        exec "$@"
    fi
}

run_command_if_only_one_match() {
    if [[ ${#matching_commands[@]} -ne 1 ]]; then
        debug "---- There were ${#matching_commands[@]} matches - not running command"
        return
    fi

    local command=${matching_commands[0]}

    # Export the command name so it can be displayed in help messages
    # Typically with a fallback to $0 if it is unset: ${BIN_COMMAND-$0}
    export BIN_COMMAND="$exe $command"

    local executable
    executable=$(map_get command_to_executable "$command")
    if [[ -n "$executable" ]]; then
        run_command "$executable" "$@"
    fi

    local script
    script=$(map_get command_to_inline_script "$command")
    if [[ -n "$script" ]]; then
        # These variables are useful for inline commands, but aren't made available
        # to regular commands because it is better to use "$(dirname "$0")" instead
        export BIN_ROOT="$root"
        export BIN_DIR="$bin_dir"

        run_command bash -c "$script" -- "$@"
    fi

    bug 'Reached the end of run_command_if_only_one_match() without running a command' # kcov-ignore-line: This should never be happen
}

#===============================================================================
# Parse parameters
#===============================================================================

help() {
    echo "Usage: bin [OPTIONS] [--] [COMMAND] [ARGUMENTS...]"
    echo
    echo "Options that can be used with a command:"
    echo "  --dir DIR             Specify the directory name to search for (overrides .binconfig)"
    echo "  --exact               Disable unique prefix matching"
    echo "  --exe NAME            Override the executable name displayed in the command list"
    echo "  --fallback COMMAND    If the command is not found, run the given global command (implies '--exact')"
    echo "  --prefix              Enable unique prefix matching (overrides .binconfig)"
    echo "  --shim                If the command is not found, run the global command with the same name (implies '--exact')"
    echo
    echo "Options that do something with a COMMAND:"
    echo "  --create, -c          Create the given script and open in your \$EDITOR (implies '--exact')"
    echo "  --edit, -e            Open the given script in your \$EDITOR"
    echo "  --print               Output the command that would have been run, instead of running it"
    echo "  --debug               Display debugging information instead of running the command"
    echo
    echo "Options that do something special and don't accept a COMMAND:"
    echo "  --completion          Output a tab completion script for the current shell"
    echo "  --shell SHELL         Override the shell to use for '--completion' -- only 'bash' is currently supported"
    echo "  --help, -h            Display this help"
    echo "  --version, -v         Display the current version number and exit"
    echo
    echo "Any options must be given before the command, because everything after the command will be passed as parameters to the script."
    echo
    echo "For more details see https://github.com/bin-cli/bin-cli#readme"
}

action=''
dir=''
debug=false
exact=''
exe=${0##*/}
error=''
fallback=''
shim=false

set_action() {
    if [[ -n $action ]]; then
        set_error "The '--$action' and '--$1' arguments are incompatible"
    fi

    action=$1
}

set_error() {
    # Don't exit immediately because '--exe' may come after the parameter with the error
    # But only display the first error encountered, as if we had exited immediately
    if [[ -z $error ]]; then
        error=$1
    fi
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --complete-bash)
            set_action complete-bash
            shift
            ;;
        --completion)
            set_action completion
            shift
            ;;
        --create | -c)
            set_action create
            shift
            ;;
        --debug)
            debug=true
            shift
            ;;
        --dir)
            dir=$2
            shift 2
            ;;
        --edit | -e)
            set_action edit
            shift
            ;;
        --exact)
            exact=true
            shift
            ;;
        --exe)
            exe=$2
            shift 2
            ;;
        --fallback)
            fallback=$2
            shift 2
            ;;
        --help | -h)
            set_action help
            shift
            ;;
        --prefix)
            exact=false
            shift
            ;;
        --print)
            set_action print
            shift
            ;;
        --shim)
            shim=true
            shift
            ;;
        --version | -v)
            set_action version
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            fail "Invalid option '$1'"
            ;;
        *)
            break
            ;;
    esac
done

if [[ -n $error ]]; then
    fail "$error"
fi

if [[ -z $action ]]; then
    action='run'
fi

#===============================================================================
# Display help / version information
#===============================================================================

debug "Bin CLI $VERSION"
debug "Working directory is '$PWD'"
debug "Action is '$action'"

if [[ $action = 'help' ]]; then
    debug_exit 'Would output help text'
    help
    exit
fi

if [[ $action = 'version' ]]; then
    debug_exit "Would print version number"
    echo "Bin CLI $VERSION"
    exit
fi

#===============================================================================
# Tab completion script generator
#===============================================================================

# This doesn't do the tab completion - it just outputs the script to be 'eval'ed

if [[ $action = 'completion' ]]; then
    complete_command=("$BIN_EXECUTABLE" --complete-bash)
    if [[ -n $dir ]]; then
        complete_command+=("--dir" "'$dir'")
    fi
    if [[ $exe != 'bin' ]]; then
        complete_command+=("--exe" "'$exe'")
    fi
    echo "complete -C \"${complete_command[*]}\" -o default $exe"
    exit
fi

#===============================================================================
# Determine paths
#===============================================================================

debug 'Determining paths...'

if [[ -n $dir ]]; then

    # Look for the given directory
    if [[ $dir = /* ]]; then
        debug "-- Using the absolute path given at the command line ($dir)"
        bin_dir=$dir

        if [[ ! -d $bin_dir ]]; then
            fail "Specified directory '$bin_dir/' is missing"
        fi
    else
        debug "-- Using the relative path given at the command line ($dir)"
        debug "-- Looking for $dir/ starting from $PWD"

        if ! dir_parent=$(findup -d "$dir"); then
            fail "Could not find '$dir/' directory starting from '$PWD'" $ERR_NOT_FOUND
        fi

        bin_dir="$dir_parent/$dir"
    fi

    # If there is no .binconfig file, assume the parent directory is the root
    binconfig=''
    root=$(dirname "$bin_dir")
    bin_dir_from_root=$(basename "$bin_dir")

    # Look for a matching .binconfig file
    debug "-- Looking for a .binconfig file starting from $bin_dir"

    if binconfig_dir=$(cd "$bin_dir" && findup -f .binconfig); then
        binconfig_file="$binconfig_dir/.binconfig"
        debug "-- Found .binconfig file $binconfig_file"

        dir_in_binconfig=$(bin_dir_for "$binconfig_file" true)
        debug "-- .binconfig has dir=$dir_in_binconfig"

        required_dir=$(relative_path "$binconfig_dir" "$bin_dir")
        debug "-- Relative path to bin dir is $required_dir"

        if [[ "$dir_in_binconfig" = "$required_dir" ]]; then
            debug "-- Using .binconfig file"
            binconfig=$binconfig_file
            root=$binconfig_dir
            bin_dir_from_root=$required_dir
        else
            debug "-- Ignoring .binconfig file because it relates to a different directory"
        fi
    fi

else

    debug "-- No directory specified at the command line"
    debug "-- Looking for a .binconfig file starting from $PWD"

    if root=$(findup -f .binconfig); then
        binconfig="${root%/}/.binconfig"
        bin_dir_from_root=$(bin_dir_for "$binconfig" true)
        bin_dir="${root%/}/$bin_dir_from_root"
    else
        debug "-- Looking for a bin/ directory starting from $PWD"

        if ! root=$(findup -d bin); then
            fail "Could not find 'bin/' directory or '.binconfig' file starting from '$PWD'" $ERR_NOT_FOUND
        fi

        binconfig="${root%/}/.binconfig"
        bin_dir_from_root='bin'
        bin_dir="${root%/}/$bin_dir_from_root"

        if in_array "$bin_dir" "$BIN_TEST_ROOT/bin" "$BIN_TEST_ROOT/usr/bin" "$BIN_TEST_ROOT/usr/local/bin" "$BIN_TEST_ROOT/snap/bin" "$HOME/bin"; then
            fail "Could not find 'bin/' directory or '.binconfig' file starting from '$PWD' (ignored '$bin_dir')" $ERR_NOT_FOUND
        fi
    fi

fi

# Special case for dir=.
is_root_dir=false
if [[ $bin_dir_from_root = '.' ]]; then
    is_root_dir=true
fi

debug "-- root=$root"
debug "-- binconfig=$binconfig"
debug "-- bin_dir=$bin_dir"
debug "-- bin_dir_from_root=$bin_dir_from_root"
debug "-- is_root_dir=$bin_dir_from_root"

#===============================================================================
# Find and register available commands
#===============================================================================

broken_symlinks=()
non_executable_files=()

# Recursive function
register_commands_in_directory() {
    local directory=$1
    local prefix=${2-}

    # Loop through the directory to find commands
    local file

    for file in "$directory/"*; do
        local name
        name=${file##*/}  # Remove path
        name=${name// /-} # Spaces to dashes

        local realfile
        realfile=$(realpath "$file") || true

        if [[ -L $file ]]; then
            local target
            target=$(readlink "$file")
            if [[ $target = /* ]]; then
                fail "The symlink '$file' must use a relative path, not absolute ('$target')"
            fi
            if [[ -e $file ]]; then
                register_executable_alias "$prefix$name" "$realfile" "$file"
            else
                debug "-- Skipped broken symlink '$file' => '$target'"
                broken_symlinks+=("$file => $target")
            fi
        elif [[ -d $file ]]; then
            # Ignore subdirectories if scripts are in the root directory,
            # because it could take a long time to search a large tree, and it's
            # unlikely someone who keeps scripts in the root would also have
            # some in subdirectories
            if $is_root_dir; then
                debug "-- Ignored subdirectory '$file'"
            else
                debug "-- Registered subdirectory '$file' to parent command '$prefix$name'"
                map_set executable_to_command "$realfile" "$prefix$name"
                debug "-- Searching subdirectory '$file'"
                register_commands_in_directory "$file" "$prefix$name "
            fi
        elif [[ ! -x $file ]]; then
            if ! $is_root_dir; then
                non_executable_files+=("$file")
            fi
            debug "-- Ignored non-executable file '$file'"
        else
            register_executable_command "$prefix$name" "$realfile"
        fi
    done
}

if [[ -d $bin_dir ]]; then
    debug "Searching '$bin_dir/' for scripts to register"
    register_commands_in_directory "$bin_dir"
else
    debug "'$bin_dir/' does not exist"
fi

#===============================================================================
# Parse config file
#===============================================================================

commands_listed_in_config=()

if [[ -f $binconfig ]]; then
    debug "Parsing $binconfig"

    command=''

    line=0
    while IFS='=' read -r key value; do
        ((line += 1))

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            command=${BASH_REMATCH[1]}
            debug "-- Found [$command] section"
            commands_listed_in_config+=("$command")
        elif [[ -z $command && $key = 'dir' ]]; then
            # Already handled (above)
            :
        elif [[ -z $command && $key = 'exact' ]]; then
            # exact=true
            if [[ -z $exact ]]; then
                # Can't use ${value,,} because it doesn't work in Bash 3 (macOS)
                if in_array "$(echo "$value" | tr '[:upper:]' '[:lower:]')" 'false' 'no' 'off' '0'; then
                    exact=false
                else
                    exact=true
                fi
                debug "-- Set 'exact' to $exact"
            else
                debug "-- Ignoring 'exact=$value' because it has already been set (in the CLI or config file)"
            fi
        elif [[ -z $command ]]; then
            # Unknown keys don't trigger an error for forwards compatibility (global)
            debug "---- Unknown global key '$key'"
        elif [[ ($key = 'alias' || $key = 'aliases') ]]; then
            # alias=blah
            # aliases=blah1, blah2
            IFS=',' read -ra line_aliases <<<"$value"
            for alias in ${line_aliases+"${line_aliases[@]}"}; do
                alias=${alias## }
                alias=${alias%% }
                register_command_alias "$alias" "$command" "$binconfig line $line"
            done
        elif [[ $key = 'command' ]]; then
            # command=echo 'Hello, World!'
            register_inline_command "$command" "$value" "$binconfig line $line"
        elif [[ $key = 'help' ]]; then
            # help=Description
            map_set help "$command" "$value"
            debug "---- Registered help for '$command'"
        else
            # Unknown keys don't trigger an error for forwards compatibility (command)
            debug "---- Unknown command key '$key'"
        fi
    done <"$binconfig" # kcov-ignore-line: Usage not detected
fi

# Default values, if not given at the command line or in the config file
if [[ -z $exact ]]; then
    exact=false
    debug "'exact' defaulted to '$exact'"
fi

#===============================================================================
# Process aliases
#===============================================================================

debug "Processing symlink aliases"

for alias in ${alias_to_executable+"${alias_to_executable[@]}"}; do
    executable=$(map_get alias_to_executable "$alias")
    if [[ -n $executable ]]; then
        command=$(map_get executable_to_command "$executable")
        map_set alias_to_command "$alias" "$command"
        debug "-- Registered alias '$alias' for executable '$executable' to command '$command'"
    fi
done

debug "Processing subcommand aliases and checking for conflicts"

for alias in ${aliases+"${aliases[@]}"}; do
    # Check for conflicts
    prevent_duplicate_command alias "$alias" "$(map_get alias_sources "$alias")"

    # Expand aliases to cover subcommands (e.g. if 'deploy'='push' then 'deploy live'='push live')
    target=$(map_get alias_to_command "$alias")
    for command in ${commands+"${commands[@]}"}; do
        if [[ "$command" = "$target "* ]]; then
            suffix=${command:${#target}}
            aliases+=("$alias$suffix")
            map_set alias_to_command "$alias$suffix" "$target$suffix"
            debug "---- Registered alias '$alias$suffix' for command '$target$suffix'"
        fi
    done
done

#===============================================================================
# Tab completion setup
#===============================================================================

last_parameter=0

if [[ $action = 'complete-bash' ]]; then
    debug "Tab completion setup:"
    debug "-- COMP_LINE='$COMP_LINE'"
    debug "-- COMP_POINT=$COMP_POINT"

    # Remove everything after the cursor, and assign everything before it to $1, $2, etc.
    args=${COMP_LINE:0:$COMP_POINT}
    debug "-- Setting parameters to '$args'"
    # shellcheck disable=SC2086
    set -- $args

    # Remove the command name
    debug "-- Removing the first parameter '$1'"
    shift

    # If there is a space at the end, we want to complete the next parameter; otherwise the last one given
    if [[ $args != *' ' ]]; then
        last_parameter=1
    fi
fi

#===============================================================================
# Parse parameters and run the command
#===============================================================================

# If no command is given, we will list all available commands
list_title='Available commands'
list_commands=(${commands+"${commands[@]}"})

# Loop through each argument until we find a matching command
debug "Processing positional parameters"
current_directory=$bin_dir
full_command=''

while [[ $# -gt $last_parameter ]]; do
    subcommand=$1
    shift

    # Special case for creating/editing the .binconfig file
    if [[ -z $full_command && $subcommand = '.binconfig' ]]; then
        if [[ $action = 'create' ]]; then
            if [[ -e "$root/.binconfig" ]]; then
                fail "$root/.binconfig already exists (use --edit to edit it)"
            fi

            ( # kcov-ignore-line: Usage not detected
                if [[ $bin_dir_from_root != 'bin' ]]; then
                    echo "dir=$bin_dir_from_root"
                else
                    echo
                fi
            ) > "$root/.binconfig" # kcov-ignore-line: Usage not detected

            echo "Created file $root/.binconfig"
            open_in_editor "$root/.binconfig"
        elif [[ $action = 'edit' ]]; then
            if [[ ! -e "$root/.binconfig" ]]; then
                fail 'No .binconfig file found (use --create to create one)'
            fi

            bin_dir_for_binconfig=$(bin_dir_for "$root/.binconfig")
            if [[ "$bin_dir_for_binconfig" != "$bin_dir_from_root" ]]; then
                fail ".binconfig belongs to $bin_dir_for_binconfig/ not $bin_dir_from_root/"
            fi

            open_in_editor "$root/.binconfig"
        fi
    fi

    # Build up the entered command in canonical format
    full_command+=" $subcommand"

    # Check if there's an exact match - run it if so
    find_matching_commands exact "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there's an almost-exact match with an added extension - run it if so
    find_matching_commands with-extension "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there are any subcommands - move on to the next argument if so
    find_matching_commands subcommands "${full_command:1}"

    if [[ ${#matching_commands[@]} -gt 0 ]]; then
        current_directory="$current_directory/$subcommand"
        list_title='Available subcommands'
        list_commands=(${matching_commands+"${matching_commands[@]}"})
        continue
    fi

    # No exact matches - check for special actions
    if [[ $action = 'create' ]]; then
        debug "No command found - creating it"

        if [[ $subcommand = .* ]]; then
            fail "Command names may not start with '.'"
        fi

        if [[ $# -gt 0 ]]; then
            current_directory="$current_directory/$subcommand"
            mkdir "$current_directory"
            echo "Created subdirectory $current_directory/"
            continue
        fi

        script="$current_directory/$subcommand"
        echo -e "#!/usr/bin/env bash\nset -eno pipefail\n\n" >"$script"
        chmod +x "$script"
        echo "Created script $script"
        open_in_editor "$script"
    elif $shim; then
        debug "No command found - using shim"
        # We want word splitting here
        # shellcheck disable=SC2086
        run_command ${full_command:1} "$@"
    elif [[ -n $fallback ]]; then
        debug "No command found - using fallback"
        # We want word splitting here - the fallback command may contain spaces to separate arguments
        # shellcheck disable=SC2086
        run_command $fallback "$@"
    fi

    # Check if there are any prefix matches
    # We need to check even with --exact so we can list them
    find_matching_commands prefix "${full_command:1}"

    if ! $exact && parent=$(matching_commands_shared_prefix "${full_command:1}"); then
        # If all matching commands have the same parent command, pretend
        # the user typed the full parent command, then continue parsing
        debug "-- Expanding partial match to '$parent'"
        current_directory="$current_directory/$parent"
        full_command=" $parent"
        list_title='Matching commands'
        list_commands=(${matching_commands+"${matching_commands[@]}"})
        continue
    fi

    if $exact; then
        debug "---- Not running match (if any) because 'exact' is $exact"
    else
        run_command_if_only_one_match "$@"
    fi

    # If there were no prefix matches, stop searching
    if [[ ${#matching_commands[@]} -eq 0 ]]; then
        if $is_root_dir && [[ -d "$current_directory/$subcommand" ]]; then
            fail "Subcommands are not supported with the config option 'dir=$bin_dir_from_root'"
        fi
        if [[ $subcommand = .* && -e "$current_directory/$subcommand" ]]; then
            fail "Command names may not start with '.'"
        fi
        if [[ -f "$current_directory/$subcommand" && ! -x "$current_directory/$subcommand" ]]; then
            fail "'$current_directory/$subcommand' is not executable (chmod +x)" $ERR_NOT_EXECUTABLE
        fi
        fail "Command '${full_command:1}' not found in $bin_dir or $binconfig" $ERR_NOT_FOUND
    fi

    # Otherwise display the list of matches
    list_title='Matching commands'
    list_commands=(${matching_commands+"${matching_commands[@]}"})
    break
done

#===============================================================================
# Determine unique command names
#===============================================================================

debug "Determining unique command names for listing"
unique_commands=()

for command in ${list_commands+"${list_commands[@]}"}; do
    executable=$(map_get command_to_executable "$command")
    if $is_root_dir && [[ $executable =~ \.(json|md|txt|yaml|yml)$ ]]; then
        debug "-- Ignored common non-executable file type '$executable' in root directory"
        continue
    fi

    short=$(remove_extension "$command")

    if [[ "$short" = "$command" ]]; then
        debug "-- '$command' can't be shortened"
        unique_commands+=("$command")
    elif has_duplicate "$short" "$command"; then
        debug "-- '$short' is not unique - using full command name '$command'"
        unique_commands+=("$command")
    else
        debug "-- '$command' shortened to '$short'"
        unique_commands+=("$short")
    fi
done

#===============================================================================
# Tab completion output
#===============================================================================

if [[ $action = 'complete-bash' ]]; then

    # Work out the full prefix we're looking for
    prefix=''
    if [[ -n $full_command ]]; then
        prefix="${full_command:1} "
    fi

    target="$prefix${1-}"

    debug "Looking for commands and aliases starting with '$target'"

    # Look for commands and aliases that match, and collect the first parameter for each
    matches=()
    matching_commands=()

    for command in ${unique_commands+"${unique_commands[@]}"}; do
        if ! command_matches prefix "$target" "$command"; then
            continue
        fi

        match=${command#"$prefix"}
        match=${match/ */}
        matches+=("$match")
        matching_commands+=("$command")
        debug "-- Found matching command '$command' => '$match'"
    done

    for alias in ${aliases+"${aliases[@]}"}; do
        if ! command_matches prefix "$target" "$alias"; then
            continue
        fi

        command=$(map_get alias_to_command "$alias")
        if in_array "$command" ${matching_commands+"${matching_commands[@]}"}; then
            debug "-- Skipping matching alias '$alias' because the command '$command' has already matched"
        else
            match=${alias#"$prefix"}
            match=${match/ */}
            matches+=("$match")
            matching_commands+=("$command")
            debug "-- Found matching alias '$alias' => '$match' (command='$command')"
        fi
    done

    # Output the matches and remove duplicates
    for command in ${matches+"${matches[@]}"}; do
        if is_hidden_command "$command" "${1-}"; then
            debug "-- '$command' is hidden - skipping"
            continue
        fi

        echo "$command"
    done | sort | uniq

    exit

fi

#===============================================================================
# List available/matching commands
#===============================================================================

# Remove hidden commands
visible_commands=()

for command in ${unique_commands+"${unique_commands[@]}"}; do
    if is_hidden_command "$command" "${full_command:1}"; then
        debug "-- '$command' is hidden - skipping"
    else
        visible_commands+=("$command")
    fi
done

# Calculate the maximum length of a command in the list so we can align the help text
maxlength=0
for command in ${visible_commands+"${visible_commands[@]}"}; do
    if [[ ${#command} -gt $maxlength ]]; then
        maxlength=${#command}
    fi
done

debug "Maximum matching command length is $maxlength"

# Output the list
get_command_aliases() {
    local command=$1
    local command_aliases=''
    local command_alias_count=0

    local alias
    for alias in ${aliases+"${aliases[@]}"}; do
        local target
        target=$(map_get alias_to_command "$alias")
        if [[ "$target" = "$command" ]]; then
            ((command_alias_count += 1))
            command_aliases+=", $alias"
        fi
    done

    if [[ $command_alias_count -eq 1 ]]; then
        echo "alias: ${command_aliases:2}"
    elif [[ $command_alias_count -gt 1 ]]; then
        echo "aliases: ${command_aliases:2}"
    fi
}

debug_exit "Would list ${#visible_commands[@]} matching command(s)"

echo "$LWHITE$BOLD$UNDERLINE$list_title$RESET"

for command in ${visible_commands+"${visible_commands[@]}"}; do
    command_help=$(map_get help "$command")
    command_aliases=$(get_command_aliases "$command")

    if [[ -n $command_help && -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help $GREY($command_aliases)$RESET"
    elif [[ -n $command_help ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help"
    elif [[ -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$GREY($command_aliases)$RESET"
    else
        printf "%s %s\n" "$exe" "$command"
    fi
done

if [[ ${#visible_commands[@]} -eq 0 ]]; then
    echo "${GREY}None found${RESET}"
fi

#===============================================================================
# Display warnings
#===============================================================================

# Broken symlinks
if [[ ${#broken_symlinks[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following symlinks point to targets that don't exist:${RESET}"
    for symlink in ${broken_symlinks+"${broken_symlinks[@]}"}; do
        echo "$symlink"
    done
fi

# Non-executable files
if [[ ${#non_executable_files[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following files are not executable (chmod +x):${RESET}"
    for file in ${non_executable_files+"${non_executable_files[@]}"}; do
        echo "$file"
    done
fi

# Missing commands in .binconfig
missing_commands=()
for command in ${commands_listed_in_config+"${commands_listed_in_config[@]}"}; do
    executable=$(map_get command_to_executable "$command")
    if [[ -z $executable ]]; then
        missing_commands+=("$command")
    fi
done

if [[ ${#missing_commands[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following commands listed in $binconfig do not exist:${RESET}"
    for command in ${missing_commands+"${missing_commands[@]}"}; do
        echo "[$command]"
    done
fi
