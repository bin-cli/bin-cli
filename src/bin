#!/usr/bin/env bash
################################################################################
# Bin - A simple task runner           Copyright (c) 2023-25 Dave James Miller #
# https://github.com/bin-cli/bin-cli   MIT License                             #
################################################################################

#===== GENERAL NOTES ===========================================================

# We use '/usr/bin/env bash' rather than '/bin/bash' in the shebang so
# it works with Bash installed in a non-standard location, e.g. with Homebrew.
#
# We require Bash, not just a standard POSIX shell like Dash[1], because we use:
# - Arrays, including associative arrays
# - '[[' for saner 'if' conditions[2]
# - Function-local variables (especially in recursive functions)
#
# There are a number of global variables. Unfortunately there's little we can do
# to avoid that, since we can't pass arrays/maps around by reference like in
# other languages, and Bash doesn't have anything equivalent to classes/objects.
# I have marked each assignment to a global variable (inside a function) with
# the comment '# global'. Every other variable set in a function should be
# marked 'local'.
#
# Since Bash doesn't support booleans, they are actually set to the strings
# 'true' or 'false', which can be evaluated directly using 'if $var; then ...'.
# (Some people argue against this style[4], but I haven't seen any convincing
# arguments why to change it...)
#
# [1]: https://wiki.archlinux.org/title/Dash
# [2]: https://stackoverflow.com/a/31366734
# [3]: https://en.wikipedia.org/wiki/POSIX
# [4]: https://stackoverflow.com/a/21210966

#======= SHELL OPTIONS =========================================================

# This has been called[1] the "unofficial bash strict mode". There are some
# downsides and edge cases[2][3], but I generally find it helpful.
#
# Specifically:
# - 'errexit', causes the script to exit if a subcommand fails (with some
#   unfortunate exceptions[2])
# - 'nounset', triggers an error when reading an unset variable (good for
#   catching typos and logic errors)
# - 'pipefail' triggers an error if any command in a pipeline fails, rather
#   than just the last command in the pipeline
#
# [1]: http://redsymbol.net/articles/unofficial-bash-strict-mode/
# [2]: https://mywiki.wooledge.org/BashFAQ/105
# [3]: https://news.ycombinator.com/item?id=11313928

set -euo pipefail

# 'nullglob' causes wildcard patterns that don't match any files to return no
# results, rather than returning the input string and requiring an extra manual
# check to see if if matched anything or not.

shopt -s nullglob

#===== VERSION =================================================================

# The version number is set by 'bin/build', which is called by 'bin/release'.
# If no version number is provided - including when running the tests - it
# defaults to '1.2.3-dev'. We'll use a slightly different version here so we can
# tell if something goes wrong with the build script.

readonly VERSION='1.2.3-source' # DO NOT CHANGE

#===== HELPERS: OUTPUT & ERROR HANDLING  =======================================

if [[ -t 1 ]]; then
    # Terminal connected - use ANSI codes
    # kcov-ignore-start: There is never a terminal connected during unit tests
    readonly RESET=$'\e[0m'
    readonly BOLD=$'\e[1m'
    readonly UNDERLINE=$'\e[4m'
    readonly YELLOW=$'\e[33m'
    readonly GREY=$'\e[90m'
    readonly LCYAN=$'\e[96m'
    readonly LWHITE=$'\e[97m'
    # kcov-ignore-end
else
    # No terminal connected - use plain output
    readonly RESET=''
    readonly BOLD=''
    readonly UNDERLINE=''
    readonly YELLOW=''
    readonly GREY=''
    readonly LCYAN=''
    readonly LWHITE=''
fi

readonly NEW_LINE=$'\n'

# We use standard Linux (Unix? POSIX?) exit codes when scripts can't be executed
# (permission denied) or can't be found. For everything else, we use a code that
# is unlikely to be returned by the scripts themselves. I chose 246 because it's
# "bin" written on a telephone keypad, as well as being sufficiently high enough
# to be unusual. (Codes above 127 typically represent "killed by signal N+127",
# but there are only 64 signals, and code 246 would represent signal 119.)

readonly ERR_NOT_EXECUTABLE=126
readonly ERR_NOT_FOUND=127
readonly ERR_GENERIC=246

# Define a function to be called when the script needs to exit with an error
# message & code, so we can do so consistently.
declare exe=${0##*/}

fail() {
    local code message

    message=$1
    code=${2-$ERR_GENERIC}

    # If we are performing tab completion, we don't want to output anything as
    # it would clobber the prompt. We'll also return a success code, since the
    # tab completion successfully returned nothing (although I don't know if
    # that makes any practical difference)
    if [[ ${action-} = 'complete-bash' ]]; then
        debug "$message"
        exit
    fi

    # Otherwise, we will prefix the error message with the executable name -
    # usually 'bin' (but it may be overridden with '--exe', or by just renaming
    # / symlinking the script)
    echo "$exe: $message" >&2
    exit "$code"
}

# When debugging, it is useful to be able to log things and dump variables to
# display on screen.
#
# We can't output debug data to either stdout (&1) or stderr (&2), because that
# would cause earlier tests to fail, so we write it to debug.txt instead. That
# is displayed on screen by the 'bin/test' script, so we include ANSI codes to
# make it a little easier to read.

readonly DEBUG_GREY=$'\e[90m'
readonly DEBUG_RESET=$'\e[0m'

debug() {
    # kcov-ignore-start: Debug statements are only added when needed
    if [[ -n ${BIN_DEBUG_LOG-} ]]; then
        local line
        line=$(debug_line)
        echo "$@" "${DEBUG_GREY}[line $line]${DEBUG_RESET}" >>"$BIN_DEBUG_LOG"
    fi
    # kcov-ignore-end
}

# We'll also output the line number, since that can be helpful when there is
# more than one debug statement, and the line numbers of the call stack,
# because why not! But we don't want them to get in the way, so we'll display
# them in a light grey colour.
#
# $BASH_LINENO is an array containing the line numbers from the stack trace.
# We remove the first (call to this function) and last (always line 0),
# convert it to a space-separated string, then replace the spaces by commas
# to get a string like 'line 132, 41, 1722'.

debug_line() {
    local lines
    lines=${BASH_LINENO[*]:1:${#BASH_LINENO[@]}-2}
    echo "${lines// /, }"
}

# If we somehow reach a place in the code that shouldn't be possible, abort and
# display the line number to help with debugging.

bug() {
    # kcov-ignore-start: This should never be needed!
    local line
    line=$(debug_line)
    fail "BUG: $1 on line $line"
    # kcov-ignore-end
}

#===== PARSE ARGUMENTS =========================================================

# We need to parse the arguments given on the command line to determine the
# action we should take, as well as various settings.
#
# Actions are mutually independent, so we'll return an error if the user
# specifies more than one. (The alternative would be silently using the last
# option given - but I think that is more confusing.)

declare action_argument=''
declare action=''

set_action() {
    # Ignore repeated arguments, e.g. '-e -e'
    if [[ "$2" = "$action" ]]; then
        return
    fi

    if [[ -n $action ]]; then
        fail "The '$action_argument' and '$1' arguments are incompatible"
    fi

    action_argument=$1 # global
    action=$2 # global
}

# Some options have required arguments - error if none is given.

set_option_value() {
    local option variable value

    option=$1
    variable=$2
    value=$3

    if [[ -z $value ]]; then
        fail "The '$option' option requires a value"
    fi

    eval "$variable=\$value" # global
}

# Now we can loop through the arguments and parse them. We stop once we reach
# one that doesn't start with a '-' - i.e. the command name. We'll also allow
# '--' to explicitly stop parsing, just for consistency with other programs -
# though I don't recommend making a command whose name starts with '-'.
#
# We allow both '--param value' and '--param=value' formats for long options.
# We don't allow combining short options - it's more complex to implement, and
# not worth it because all the short options are mutually exclusive.
#
# We can't use 'getopt', 'getopts', etc. to help with this because we don't want
# to clobber anything after the command name - we need to keep them intact to
# pass to the command.

declare fixed_bin_dir=''
declare is_custom_exe=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --complete-bash)    set_action "$1" complete-bash ;;
        --completion)       set_action "$1" completion ;;
        --dir)              set_option_value '--dir' fixed_bin_dir "${2-}"; shift ;;
        --dir=*)            set_option_value '--dir' fixed_bin_dir "${1#*=}" ;;
        --exe)              is_custom_exe=true; set_option_value '--exe' exe "${2-}"; shift ;;
        --exe=*)            is_custom_exe=true; set_option_value '--exe' exe "${1#*=}" ;;
        --help | -h)        set_action "$1" help ;;
        --version | -v)     set_action "$1" version ;;
        --)                 shift; break ;;
        -*)                 fail "Invalid option '$1'" ;;
        *)                  break ;;
    esac

    shift
done

#===== SIMPLE ACTIONS: VERSION / HELP / COMPLETION SCRIPT ======================

# These actions don't require us to parse any config files or register commands.

if [[ $action = 'version' ]]; then
    echo "Bin CLI v$VERSION"
    exit
fi

if [[ $action = 'help' ]]; then
    echo "Usage: $exe [OPTIONS] [--] [COMMAND] [ARGUMENTS...]"
    echo
    echo "Options that can be used with a command:"
    echo "  --dir DIR             Specify the directory name to search for (absolute or relative path)"
    echo "  --exe NAME            Override the executable name displayed in the command list"
    echo
    echo "Options that do something special:"
    echo "  --completion          Output a tab completion script for the current shell"
    echo "  --help, -h            Display this help"
    echo "  --version, -v         Display the current version number"
    echo
    echo "Any options must be given before the command, because everything after the command will be passed as parameters to the script."
    echo
    echo "For more details see https://github.com/bin-cli/bin-cli/tree/v$VERSION#readme"
    exit
fi

# This doesn't do the tab completion - it just outputs the script to be 'eval'ed
# in the shell to enable tab completion.
if [[ $action = 'completion' ]]; then
    declare complete_command=("$(basename "$0")")
    if $is_custom_exe; then
        complete_command+=("--exe" "'$exe'")
    fi
    if [[ -n $fixed_bin_dir ]]; then
        complete_command+=("--dir" "'$fixed_bin_dir'")
    fi
    echo "complete -C \"${complete_command[*]} --complete-bash\" -o default $exe"
    exit
fi

#===== PREPARE FOR TAB COMPLETION (IF NEEDED) ==================================

declare -i num_parameters_to_ignore=0

if [[ $action = 'complete-bash' ]]; then

    # The command being completed is available in $COMP_LINE.
    # The current cursor position is available in $COMP_POINT.
    # Ignore everything after the cursor, and assign everything before it to $1,
    # $2, etc. as if it had been executed already.
    declare args=${COMP_LINE:0:$COMP_POINT}

    # shellcheck disable=SC2086 # We want this to be split into separate arguments
    # Note: This doesn't handle quotes properly - but I couldn't come up with anything better!
    # ('eval' works if quotes are balanced but errors if not, and is potentially unsafe)
    set -- $args

    # Remove the command name (since that would be in $0 not $1)
    shift

    # If there is a space at the end, we want to complete the next parameter; otherwise the last one given
    if [[ $args != *' ' ]]; then
        num_parameters_to_ignore=1
    fi

    # Parse options used on the command line
    can_have_more_options=true

    while [[ $# -gt $num_parameters_to_ignore ]]; do
        case $1 in
            --complete-bash)    fail "Cannot tab complete '$1'" ;;
            --completion)       fail "Cannot tab complete '$1'" ;;
            --dir)              set_option_value '--dir' fixed_bin_dir "${2-}"; shift ;;
            --dir=*)            set_option_value '--dir' fixed_bin_dir "${1#*=}" ;;
            --exe)              is_custom_exe=true; set_option_value '--exe' exe "${2-}"; shift ;;
            --exe=*)            is_custom_exe=true; set_option_value '--exe' exe "${1#*=}" ;;
            --help | -h)        fail "Cannot tab complete '$1'" ;;
            --version | -v)     fail "Cannot tab complete '$1'" ;;
            --)                 can_have_more_options=false; shift; break ;;
            -*)                 fail "Invalid option '$1'" ;;
            *)                  break ;;
        esac

        shift
    done

    # Tab-complete option names (but only if the '-' is typed)
    # (We don't currently support tab-completing the values - e.g. directory names for --dir)
    if $can_have_more_options && [[ ${1-} = -* ]]; then

        # kcov-ignore-start: Usage not detected
        declare option_names=(
            # '--complete-bash' # Shouldn't normally be entered by hand
            '--completion'
            '--dir'
            '--exe'
            '--help' '-h'
            '--version' '-v'
            '--'
        )
        # kcov-ignore-end

        declare option_name
        for option_name in "${option_names[@]}"; do
            if [[ $option_name = "$1"* ]]; then
                # 'echo' treats '-e' as an option rather than the string to output
                printf "%s\n" "$option_name"
            fi
        done

        exit
    fi

fi

#===== HELPERS: ARRAYS =========================================================

in_array() {
    local needle value

    needle=$1
    shift

    for value in "$@"; do
        if [[ "$value" = "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

#===== HELPERS: FILESYSTEM =====================================================

# The BIN_TEST_ROOT env var is ignored in production builds, but is used as
# an alternative to 'chroot' (which doesn't work on all OS's) in the tests
if [[ $VERSION = '1.2.3-dev' ]]; then
    readonly ROOT_DIR=${BIN_TEST_ROOT-}
else
    readonly ROOT_DIR='' # kcov-ignore-line: Not tested
fi

findup() (
    cd "$1"
    shift

    while true; do

        if test "$@"; then
            echo "$PWD"
            return 0
        fi

        if [[ ${PWD%/} = "$ROOT_DIR" ]]; then
            return 1
        fi

        cd ..

    done
)

is_common_bin_dir() {
    in_array "$1" \
        "$ROOT_DIR/bin" \
        "$ROOT_DIR/usr/bin" \
        "$ROOT_DIR/usr/local/bin" \
        "$ROOT_DIR/snap/bin" \
        "$HOME/.local/bin" \
        "$HOME/bin"
}

#===== HELPERS: CROSS-PLATFORM 'realpath' ======================================

# Based on: https://github.com/mkropat/sh-realpath/blob/65512368b8155b176b67122aa395ac580d9acc5b/realpath.sh
# Copyright (c) 2014 Michael Kropat - MIT License
# Modified to work with 'set -e', and to follow our code conventions

# kcov-ignore-start: Not every code path is covered by our tests
realpath() {
    local resolved
    resolved=$(resolve_symlinks "$1")
    canonicalize_path "$resolved"
}

resolve_symlinks() {
    _resolve_symlinks "$1"
}

_resolve_symlinks() {
    _assert_no_path_cycles "$@" || return

    local dir_context new_context path

    if path=$(readlink -- "$1"); then
        dir_context=$(dirname -- "$1")
        new_context=$(_prepend_dir_context_if_necessary "$dir_context" "$path")
        _resolve_symlinks "$new_context" "$@"
    else
        echo "$1"
    fi
}

_prepend_dir_context_if_necessary() {
    if [[ $1 = '.' ]]; then
        echo "$2"
    else
        _prepend_path_if_relative "$1" "$2"
    fi
}

_prepend_path_if_relative() {
    case "$2" in
        /*) echo "$2" ;;
        *) echo "$1/$2" ;;
    esac
}

_assert_no_path_cycles() {
    local target path

    target=$1
    shift

    for path in "$@"; do
        if [[ "$path" = "$target" ]]; then
            return 1
        fi
    done
}

canonicalize_path() {
    if [[ -d $1 ]]; then
        _canonicalize_dir_path "$1"
    else
        _canonicalize_file_path "$1"
    fi
}

_canonicalize_dir_path() {
    (cd "$1" 2>/dev/null && pwd -P)
}

_canonicalize_file_path() {
    local dir file
    dir=$(dirname -- "$1")
    file=$(basename -- "$1")

    (cd "$dir" 2>/dev/null && dir2=$(pwd -P) && echo "$dir2/$file")
}
# kcov-ignore-end

#===== HELPERS: REGISTER COMMANDS ==============================================

# Before we can run any commands, we need to make a list of them all. This
# allows us to support unique prefix matching, detect conflicts, and so on.
# Regular commands are implemented as executables / shell scripts.

declare -a broken_symlinks=()
declare -a non_executable_files=()
declare -a registered_commands=()
declare -gA command_to_executable=()
declare -gA executable_to_command=()
declare -gA original_commands=()

register_executable_command() {
    local executable name

    name=$1
    executable=$2

    registered_commands+=("$name")             # global
    command_to_executable[$name]="$executable" # global
    executable_to_command[$executable]="$name" # global
    original_commands[$name]="$name"           # global
}

register_commands_in_directory() {
    local directory file name prefix realfile target

    directory=$1
    prefix=${2-}

    # Loop through the directory to find commands
    for file in "$directory/"*; do
        name=${file##*/}  # Remove path
        name=${name// /-} # Spaces to dashes

        realfile=$(realpath "$file") || true

        if [[ -L $file ]]; then
            target=$(readlink "$file")
            if [[ $target = /* ]]; then
                fail "The symlink '$file' must use a relative path, not absolute ('$target')"
            fi
            if [[ -e $file ]]; then
                register_alias "$prefix$name" "$realfile"
            else
                broken_symlinks+=("$file => $target")
            fi
        elif [[ -d $file ]]; then
            executable_to_command[$realfile]="$prefix$name" # global
            register_commands_in_directory "$file" "$prefix$name "
        elif [[ ! -x $file ]]; then
            non_executable_files+=("$file") # global
        else
            register_executable_command "$prefix$name" "$realfile"
        fi
    done
}

#===== HELPERS: ALIASES ========================================================

declare -a registered_aliases=()
declare -gA alias_to_executable=()

register_alias() {
    local alias executable

    alias=$1
    executable=$2

    registered_aliases+=("$alias")                     # global
    alias_to_executable["$alias"]="$executable" # global
}

#===== HELPERS: SEARCH FOR COMMANDS ============================================

declare -a matching_commands=()

command_matches() {
    local command found target type

    type=$1
    target=$2
    command=$3

    # Check for a match of the given type
    found=false

    if [[ $type = exact ]]; then
        [[ "$command" = "$target" ]] && found=true
    elif [[ $type = subcommands ]]; then
        [[ "$command" = "$target "* ]] && found=true
    elif [[ $type = prefix ]]; then
        [[ "$command" = "$target"* ]] && found=true
    else
        bug "Invalid \$type '$type' passed to command_matches()" # kcov-ignore-line: This should never be happen
    fi

    # If it doesn't match, return false
    if ! $found; then
        return 1
    fi

    return 0
}

find_matching_commands() {
    local alias command target type

    type=$1
    target=$2

    # Find commands and aliases that match
    matching_commands=() # global
    declare -gA matched_original_commands=() # global

    for command in "${registered_commands[@]}" "${registered_aliases[@]}"; do

        # Don't match the same command more than once, even if it has aliases that also match
        original_command="${original_commands[$command]}"
        if [[ -v matched_original_commands[$original_command] ]]; then
            continue
        fi

        # Ignore aliases that don't actually map to a valid command
        if [[ ! -v command_to_executable[$original_command] ]]; then
            continue
        fi

        # Check if the command actually matches (after the above checks because this is more expensive)
        if ! command_matches "$type" "$target" "$command"; then
            continue
        fi

        # It does match, so add it to the results
        matching_commands+=("$command") # global
        matched_original_commands["$original_command"]=true # global
    done
}

matching_commands_shared_prefix() {
    local command next_command prefix prefix_length remaining shared_next_command

    prefix=$1
    prefix_length=${#prefix}

    shared_next_command=''

    for command in "${matching_commands[@]}"; do
        # Remove the common prefix
        remaining=${command:$prefix_length}

        if [[ ! $remaining = *' '* ]]; then
            continue
        fi

        next_command=${remaining/ */}

        if [[ -z $shared_next_command ]]; then
            shared_next_command=$next_command
        elif [[ "$next_command" != "$shared_next_command" ]]; then
            # Not unique
            return 1
        fi
    done

    if [[ -n $shared_next_command ]]; then
        echo "$prefix$shared_next_command"
    else
        # No subcommands found
        return 1
    fi
}

#===== HELPERS: RUN COMMANDS ===================================================

run_command() {
    if [[ $action = 'complete-bash' ]]; then
        bug 'run_command() should not be reached during tab completion' # kcov-ignore-line: This should never be happen
    else
        exec "$@"
    fi
}

run_command_if_only_one_match() {
    local command executable root

    if [[ ${#matching_commands[@]} -ne 1 ]]; then
        return
    fi

    command="${original_commands[${matching_commands[0]}]}"

    # Export the command name so it can be displayed in help messages
    # Typically with a fallback to $0 if it is unset: ${BIN_COMMAND-$0}
    export BIN_COMMAND="$exe $command"

    # And this can be used to display other command names
    export BIN_EXE="$exe"

    run_command "${command_to_executable[$command]}" "$@"
}

#===== REGISTER COMMANDS & CONFIG FILES ========================================

declare root=''
declare bin_dir=''

# Determine paths
if [[ -n $fixed_bin_dir ]]; then

    # Look for given directory given by '--dir', which can either be an absolute
    # path, which is searched directly, or a directory name, which is found
    # by searching upwards from the current working directory as normal.

    if [[ $fixed_bin_dir = /* ]]; then
        # Absolute path
        if [[ ! -d $fixed_bin_dir ]]; then
            fail "Specified directory '$fixed_bin_dir/' is missing"
        fi

        bin_dir=$fixed_bin_dir
    else
        # Directory name
        if ! dir_parent=$(findup "$PWD" -d "$fixed_bin_dir"); then
            fail "Could not find '$fixed_bin_dir/' directory starting from '$PWD'" $ERR_NOT_FOUND
        fi

        bin_dir="$dir_parent/$fixed_bin_dir"
        fixed_bin_dir=''
    fi

    root=$(dirname "$bin_dir")

else

    # Otherwise search for a bin/ directory
    if ! root=$(findup "$PWD" -d bin); then
        fail "Could not find 'bin/' directory starting from '$PWD'" $ERR_NOT_FOUND
    fi

    bin_dir="${root%/}/bin"

    # Ignore common global bin/ directories (/bin, /usr/bin, etc.)
    if is_common_bin_dir "$bin_dir"; then
        fail "Could not find 'bin/' directory starting from '$PWD' (ignored '$bin_dir')" $ERR_NOT_FOUND
    fi
fi

# Find and register available commands
if [[ -d $bin_dir ]]; then
    register_commands_in_directory "$bin_dir"
fi

# Map symlink aliases to their underlying commands, now we know all the commands
for alias in "${!alias_to_executable[@]}"; do
    executable="${alias_to_executable[$alias]}"
    if [[ -n $executable ]]; then
        command="${executable_to_command[$executable]}"
        original_commands[$alias]="$command"
    fi
done

for alias in "${registered_aliases[@]}"; do
    # Expand aliases to cover subcommands (e.g. if 'deploy' => 'push' then 'deploy live' => 'push live')
    target="${original_commands[$alias]}"
    for command in "${registered_commands[@]}"; do
        if [[ "$command" = "$target "* ]]; then
            suffix=${command:${#target}}
            registered_aliases+=("$alias$suffix")
            original_commands["$alias$suffix"]="$target$suffix"
        fi
    done
done

#===== PARSE PARAMETERS AND FIND/RUN THE COMMAND ===============================

# If no command is given, we will list all available commands
declare command_list_title='Available Commands'
declare -a command_list=("${registered_commands[@]}")

# Loop through each argument until we find a matching command
declare current_directory=$bin_dir
declare full_command=''

while [[ $# -gt $num_parameters_to_ignore ]]; do
    declare subcommand=$1
    shift

    # Build up the entered command in canonical format
    full_command+=" $subcommand"

    # Check if there's an exact match - run it if so
    find_matching_commands exact "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there are any subcommands - move on to the next argument if so
    find_matching_commands subcommands "${full_command:1}"

    if [[ ${#matching_commands[@]} -gt 0 ]]; then
        current_directory="$current_directory/$subcommand"
        command_list_title='Available Subcommands'
        command_list=("${matching_commands[@]}")
        continue
    fi

    # Check if there are any prefix matches
    find_matching_commands prefix "${full_command:1}"

    if parent=$(matching_commands_shared_prefix "${full_command:1}"); then
        # If all matching commands have the same parent command, pretend
        # the user typed the full parent command, then continue parsing
        current_directory="$current_directory/$parent"
        full_command=" $parent"
        command_list_title='Matching Commands'
        command_list=("${matching_commands[@]}")
        continue
    fi

    run_command_if_only_one_match "$@"

    # If there were no prefix matches, stop searching
    if [[ ${#matching_commands[@]} -eq 0 ]]; then
        if [[ $subcommand = .* && -e "$current_directory/$subcommand" ]]; then
            fail "Command names may not start with '.'"
        fi
        if [[ -f "$current_directory/$subcommand" && ! -x "$current_directory/$subcommand" ]]; then
            fail "'$current_directory/$subcommand' is not executable (chmod +x)" $ERR_NOT_EXECUTABLE
        fi

        append=''
        if in_array "${full_command:1}" completion help version; then
            append="${append}${NEW_LINE}${GREY}Perhaps you meant to run 'bin --${full_command:1}'?${RESET}"
        fi
        fail "Command '${full_command:1}' not found in $bin_dir/$append" $ERR_NOT_FOUND
    fi

    # Otherwise display the list of matches
    command_list_title='Matching Commands'
    command_list=("${matching_commands[@]}")
    break
done

#===== TAB COMPLETION OUTPUT ===================================================

if [[ $action = 'complete-bash' ]]; then

    # Work out the full prefix we're looking for
    declare parent_command=''
    if [[ -n $full_command ]]; then
        parent_command="${full_command:1} "
    fi

    declare current_command=${1-}
    declare typed_command="$parent_command$current_command"

    # Look for commands and aliases that match, and collect the first parameter for each
    declare alias command match
    declare -a possible_results=()
    declare -a matched_commands=()

    for command in "${command_list[@]}"; do
        if ! command_matches prefix "$typed_command" "$command"; then
            continue
        fi

        match=${command#"$parent_command"} # Remove everything before the current argument
        match=${match/ */} # Remove everything after the current argument (i.e. subcommands)
        possible_results+=("$match")
        matched_commands+=("$command")
    done

    for alias in "${registered_aliases[@]}"; do
        if ! command_matches prefix "$typed_command" "$alias"; then
            continue
        fi

        # Only list each command once - it doesn't matter which variant is
        # typed, and Readline (by default) will only use the completion if
        # there is single match (otherwise it just lists the possible matches)
        command="${original_commands[$alias]}"
        if in_array "$command" "${matched_commands[@]}"; then
            continue
        fi

        match=${alias#"$parent_command"} # Remove everything before the current argument
        match=${match/ */} # Remove everything after the current argument (i.e. subcommands)
        possible_results+=("$match")
        matched_commands+=("$command")
    done

    # Output the matches and remove duplicates
    for result in "${possible_results[@]}"; do
        echo "$result"
    done | sort | uniq

    exit
fi

#===== LIST COMMANDS ===========================================================

# Helper to get the aliases for a command
get_command_aliases() {
    local alias command command_alias_count command_aliases original_command target

    command=$1

    command_alias_count=0
    command_aliases=''

    original_command="${original_commands[$command]}"

    for alias in "${registered_aliases[@]}"; do
        target="${original_commands[$alias]}"
        if [[ "$target" = "$original_command" ]]; then
            ((command_alias_count += 1))
            command_aliases+=", $alias"
        fi
    done

    if [[ $command_alias_count -eq 1 ]]; then
        echo "alias: ${command_aliases:2}"
    elif [[ $command_alias_count -gt 1 ]]; then
        echo "aliases: ${command_aliases:2}"
    else
        return 1
    fi
}

# Output the title
echo "$LCYAN$BOLD$UNDERLINE$command_list_title$RESET"

# Output the list of commands
declare command command_aliases

for command in "${command_list[@]}"; do
    echo -n "${LWHITE}${exe} ${command}${RESET}"

    if aliases=$(get_command_aliases "$command"); then
        echo -n " ${GREY}(${aliases})${RESET}"
    fi

    # New line
    echo
done | sort

if [[ ${#command_list[@]} -eq 0 ]]; then
    echo "${GREY}None found${RESET}"
fi

# Warnings: Broken symlinks
if [[ ${#broken_symlinks[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following symlinks point to targets that don't exist:${RESET}"
    declare symlink
    for symlink in "${broken_symlinks[@]}"; do
        echo "$symlink"
    done
fi

# Warnings: Non-executable files
if [[ ${#non_executable_files[@]} -gt 0 ]]; then
    echo
    echo "${YELLOW}Warning: The following files are not executable (chmod +x):${RESET}"
    declare file
    for file in "${non_executable_files[@]}"; do
        echo "$file"
    done
fi

