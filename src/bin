#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail
shopt -s nullglob

################################################################################
# Bin - A simple task runner        Copyright (c) 2023 Dave James Miller       #
# https://bin-cli.com/              MIT License                                #
################################################################################

#===============================================================================
# Constants
#===============================================================================

# Version (set by build script - don't change in source file)
VERSION='1.2.3-dev'

# ANSI codes
if [[ -t 1 ]]; then
    # kcov-ignore-start: There is never a terminal connected during unit tests
    TITLE=$(printf "\e[97;1;4m") # White, bold, underline
    WARNING=$(printf "\e[33m")
    GREY=$(printf "\e[90m")
    RESET=$(printf "\e[0m")
    # kcov-ignore-end
else
    TITLE=''
    WARNING=''
    GREY=''
    RESET=''
fi

# The debug output always goes to a terminal, but indirectly
DEBUG_LINE=$(printf "\e[90m")
DEBUG_RESET=$(printf "\e[0m")

# Exit codes
ERR_NOT_EXECUTABLE=126
ERR_NOT_FOUND=127
ERR_GENERIC=246

#===============================================================================
# General helpers
#===============================================================================

in_array() {
    local needle=$1
    shift

    for value in "$@"; do
        if [[ "$value" = "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

#===============================================================================
# Output helpers
#===============================================================================

# This is a bit of a hack so we can use 'debug' inside functions where stdout is redirected
exec 4>&1

debug() {
    # Display debug data when using --debug (only after parsing parameters)
    if ${debug-false}; then
        echo "$@" >&4
    fi

    # Output debug data to FD 3 when using the 'bin tdd' script in development
    if { true >&3; } 2>/dev/null; then # kcov-ignore-line: Usage not detected
        local lines="${BASH_LINENO[*]}"
        lines=${lines% 0}
        echo "$@" "$DEBUG_LINE[line ${lines// /, }]$DEBUG_RESET" >&3
    fi
}

debug_exit() {
    debug "$@"
    if ${debug-false}; then
        exit
    fi
}

fail() {
    local message=$1
    local code=${2-$ERR_GENERIC}

    debug "Failed with message: $message"
    debug_exit "Exit code: $code"

    if [[ $action = 'complete-bash' ]]; then
        exit
    fi

    echo "$exe: $message" >&2
    exit "$code"
}

bug() {
    # kcov-ignore-start: This should never be needed!
    local lines="${BASH_LINENO[*]}"
    lines=${lines% 0}
    fail "BUG: $1 on line ${lines// /, }"
    # kcov-ignore-end
}

#===============================================================================
# Parse parameters
#===============================================================================

help() {
    echo "Usage: bin [OPTIONS] [--] [COMMAND] [ARGUMENTS...]"
    echo
    echo "Options that can be used with a command:"
    echo "  --dir DIR             Specify the directory name to search for (overrides .binconfig)"
    echo "  --exact               Disable unique prefix matching"
    echo "  --exe NAME            Override the executable name displayed in the command list"
    echo "  --fallback COMMAND    If the command is not found, run the given global command (implies '--exact')"
    echo "  --prefix              Enable unique prefix matching (overrides .binconfig)"
    echo "  --shim                If the command is not found, run the global command with the same name (implies '--exact')"
    echo
    echo "Options that do something special:"
    echo "  --completion          Output a tab completion script for the current shell"
    echo "  --debug               Display debugging information instead of running a command"
    echo "  --help, -h            Display this help"
    echo "  --print               Output the command that would have been run, instead of running it"
    echo "  --shell SHELL         Override the shell to use for '--completion' -- only 'bash' is currently supported"
    echo "  --version, -v         Display the current version number and exit"
    echo
    echo "Any options must be given before the command, because everything after the command will be passed as parameters to the script."
}

action=''
bin_dirname=''
debug=false
exact=''
exe=${0##*/}
error=''
fallback=''
shim=false

set_action() {
    if [[ -n $action ]]; then
        set_error "The '--$action' and '--$1' arguments are incompatible"
    fi

    action=$1
}

set_error() {
    # Don't exit immediately because '--exe' may come after the parameter with the error
    # But only display the first error encountered, as if we had exited immediately
    if [[ -z $error ]]; then
        error=$1
    fi
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --complete-bash)
            set_action complete-bash
            shift
            ;;
        --completion)
            set_action completion
            shift
            ;;
        --debug)
            debug=true
            shift
            ;;
        --dir)
            bin_dirname=$2
            shift 2
            ;;
        --exact)
            exact=true
            shift
            ;;
        --exe)
            exe=$2
            shift 2
            ;;
        --fallback)
            fallback=$2
            shift 2
            ;;
        --help | -h)
            set_action help
            shift
            ;;
        --prefix)
            exact=false
            shift
            ;;
        --print)
            set_action print
            shift
            ;;
        --shim)
            shim=true
            shift
            ;;
        --version | -v)
            set_action version
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            fail "Invalid option '$1'"
            ;;
        *) break ;;
    esac
done

if [[ -n $error ]]; then
    fail "$error"
fi

#===============================================================================
# Display help / version information
#===============================================================================

debug "Bin version $VERSION"

if [[ -n $action ]]; then
    debug "Action set to '$action'"
fi

if [[ $action = 'help' ]]; then
    debug_exit 'Would output help text'
    help
    exit
fi

if [[ $action = 'version' ]]; then
    debug_exit "Would print version number"
    echo "Bin version $VERSION"
    exit
fi

#===============================================================================
# Tab completion script generator
#===============================================================================

if [[ $action = 'completion' ]]; then
    command=("$(realpath "$0")" --complete-bash)
    if [[ -n $bin_dirname ]]; then
        command+=("--dir" "'$bin_dirname'")
    fi
    if [[ $exe != 'bin' ]]; then
        command+=("--exe" "'$exe'")
    fi
    echo "complete -C \"${command[*]}\" -o default $exe"
    exit
fi

#===============================================================================
# Alias helpers
#===============================================================================

aliases=()
declare -A alias_to_command
declare -A alias_to_executable
declare -A alias_sources

register_command_alias() {
    local alias=$1
    local command=$2
    local source=$3

    if [[ -n ${alias_sources[$alias]-} ]]; then
        fail "The alias '$alias' defined in $source conflicts with the alias defined in ${alias_sources[$alias]}"
    fi

    aliases+=("$alias")
    alias_to_command[$alias]=$command
    alias_sources[$alias]=$source

    debug "  Registered alias '$alias' for command '$command'"
}

register_executable_alias() {
    local alias=$1
    local executable=$2
    local source=$3

    if [[ -n ${alias_sources[$alias]-} ]]; then
        fail "The alias '$alias' defined in $source conflicts with the alias defined in ${alias_sources[$alias]}"
    fi

    aliases+=("$alias")
    alias_to_executable[$alias]=$executable
    alias_sources[$alias]=$source

    debug "  Registered alias '$alias' for executable '$executable'"
}

process_aliases() {
    # Match symlink aliases with their commands
    debug "Processing symlink aliases"

    local alias
    for alias in "${!alias_to_executable[@]}"; do
        local executable=${alias_to_executable[$alias]-}
        if [[ -n $executable ]]; then
            local command=${executable_to_command[$executable]-}
            alias_to_command[$alias]=$command
            debug "  Registered alias '$alias' for executable '$executable' to command '$command'"
        fi
    done

    debug "Processing directory aliases and checking for conflicts"

    for alias in "${aliases[@]}"; do
        # Check for conflicts
        if [[ -n "${command_to_executable[$alias]-}" ]]; then
            fail "The alias '$alias' defined in ${alias_sources[$alias]} conflicts with an existing command"
        fi

        # Expand aliases to cover subcommands (e.g. if 'deploy'='push' then 'deploy live'='push live')
        target=${alias_to_command[$alias]}
        for command in "${commands[@]}"; do
            if [[ "$command" = "$target "* ]]; then
                suffix=${command:${#target}}
                aliases+=("$alias$suffix")
                alias_to_command[$alias$suffix]="$target$suffix"
                debug "    Registered alias '$alias$suffix' for command '$target$suffix'"
            fi
        done
    done
}

#===============================================================================
# Directory search helper
#===============================================================================

findup() (
    while true; do
        if test "$@"; then
            debug "  $PWD - found"
            echo "$PWD"
            return 0
        else
            debug "  $PWD - not found"
        fi

        if [[ $PWD = '/' ]]; then
            return 1
        fi

        cd ..

    done
)

#===============================================================================
# Locate config file
#===============================================================================

binconfig=''
declare -A help

debug "Working directory is $PWD"

# Initial search & parse to find the dir= setting only
# That way we don't need to "undo" everything we did if it doesn't match
debug "Looking for a .binconfig file in:"

if root=$(findup -f .binconfig); then
    binconfig="$root/.binconfig"
    bin_dirname_from_config=''

    debug "Checking $binconfig for a 'dir' setting"

    line=0
    while IFS='=' read -r key value; do
        ((line += 1))

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            debug "  Reached section $key - giving up"
            break
        elif [[ $key = 'dir' ]]; then
            # dir=scripts
            debug "  Found $key=$value"
            bin_dirname_from_config=$value
            break
        fi
    done <"$binconfig" # kcov-ignore-line: Usage not detected

    if [[ -z $bin_dirname_from_config ]]; then
        debug "  Not found"
    fi

    if [[ $bin_dirname_from_config = /* ]]; then
        fail "The option 'dir' cannot be an absolute path in $binconfig line $line"
    elif [[ "$(realpath "$root/$bin_dirname_from_config")/" != "$(realpath "$root")/"* ]]; then
        fail "The option 'dir' cannot point to a directory outside $root in $binconfig line $line"
    elif [[ -z $bin_dirname ]]; then
        # If no directory was given at the command line, use the one from the config file
        debug "  Using '$bin_dirname_from_config' from the config file"
        bin_dirname=$bin_dirname_from_config
    elif [[ "$bin_dirname_from_config" != "$bin_dirname" ]]; then
        # If the directory given at the command line doesn't match the config file,
        # ignore the rest of the config file, and don't treat this as the root
        debug "  The config file setting '$bin_dirname_from_config' doesn't match the CLI setting '$bin_dirname' - ignoring config file"
        binconfig=''
    fi
fi

#===============================================================================
# Parse config file
#===============================================================================

if [[ -n $binconfig ]]; then
    debug "Parsing $binconfig"

    command=''

    line=0
    while IFS='=' read -r key value; do
        ((line += 1))

        if [[ $key = '' || $key = '#'* || $key = ';'* ]]; then
            # Skip blank lines & comments
            :
        elif [[ $key =~ ^\[(.+)]$ ]]; then
            # [command]
            command=${BASH_REMATCH[1]}
            debug "  Found [$command] section"
        elif [[ -z $command && $key = 'dir' ]]; then
            # Already handled
            :
        elif [[ -z $command && $key = 'exact' ]]; then
            # exact=true
            if [[ -z $exact ]]; then
                if in_array "${value,,}" 'false' 'no' 'off' '0'; then
                    exact=false
                else
                    exact=true
                fi
                debug "  Set 'exact' to $exact"
            else
                debug "  Ignoring 'exact=$value' because it has already been set (in the CLI or config file)"
            fi
        elif [[ -z $command ]]; then
            # Unknown keys don't trigger an error for forwards compatibility (global)
            debug "  Unknown key '$key'"
        elif [[ ($key = 'alias' || $key = 'aliases') ]]; then
            # alias=blah
            # aliases=blah1, blah2
            IFS=',' read -ra line_aliases <<<"$value"
            for alias in "${line_aliases[@]}"; do
                alias=${alias// /}
                register_command_alias "$alias" "$command" "$binconfig line $line"
                debug "    Registered alias '$alias'"
            done
        elif [[ $key = 'help' ]]; then
            # help=Description
            help[$command]=$value
            debug "    Registered help for '$command'"
        else
            # Unknown keys don't trigger an error for forwards compatibility (command)
            debug "    Unknown key '$key'"
        fi
    done <"$binconfig" # kcov-ignore-line: Usage not detected
fi

# Default values, if not given at the command line or in the config file
if [[ -z $bin_dirname ]]; then
    bin_dirname=bin
    debug "'dir' defaulted to '$bin_dirname'"
fi

if [[ -z $exact ]]; then
    exact=false
    debug "'exact' defaulted to '$exact'"
fi

#===============================================================================
# Locate the bin/ directory
#===============================================================================

is_root_dir=false

if [[ -n $binconfig ]]; then

    # If a .binconfig file exists, that takes precedence
    if [[ ${bin_dirname%%/} = '.' ]]; then
        # Special case for the root directory (see docs)
        bin_directory=$root
        is_root_dir=true
        debug "Bin directory set to '$bin_directory' (root) from config file"
    else
        bin_directory="${root%%/}/$bin_dirname"
        debug "Bin directory set to '$bin_directory' from config file"
    fi

    if [[ ! -d $bin_directory ]]; then
        fail "Found '$binconfig', but '$bin_directory/' directory is missing"
    fi

elif [[ $bin_dirname = '/'* ]]; then

    # Absolute path given at the command line
    bin_directory="$bin_dirname"
    debug "Bin directory set to '$bin_directory' (absolute) from CLI"

    if [[ ! -d $bin_directory ]]; then
        fail "Specified directory '$bin_directory/' is missing"
    fi

else

    # If there is no .binconfig, look for a bin/ directory instead (or other name specified with --dir)
    debug "Looking for a $bin_dirname/ directory in:"
    if root=$(findup -d "$bin_dirname"); then
        bin_directory="${root%%/}/$bin_dirname"
        debug "Bin directory set to '$bin_directory'"
    else
        fail "Could not find '$bin_dirname/' directory or '.binconfig' file starting from '$PWD'" $ERR_NOT_FOUND
    fi

    # Check for special cases that we only allow with a matching .binconfig file
    if in_array $bin_directory '/bin' '/usr/bin' '/usr/local/bin' '/snap/bin' "$HOME/bin"; then
        fail "Could not find '$bin_dirname/' directory or '.binconfig' file starting from '$PWD' (ignored '$bin_directory')" $ERR_NOT_FOUND
    fi

fi

#===============================================================================
# Find and register available commands
#===============================================================================

commands=()
non_executable_files=()

declare -A command_to_executable
declare -A executable_to_command

register_commands() {
    local directory=$1
    local prefix=${2-}

    local file
    local name
    local target

    # Loop through the directory to find commands
    for file in "$directory/"*; do
        realfile="$(realpath "$file")"

        name=${file##*/} # Remove path
        name=${name// /-} # Spaces to dashes

        if [[ -L $file ]]; then
            target=$(readlink "$file")
            if [[ $target = /* ]]; then
                fail "The symlink '$file' must use a relative path, not absolute ('$target')"
            fi
            register_executable_alias "$prefix$name" "$realfile" "$file"
        elif [[ -d $file ]]; then
            # Ignore subdirectories if scripts are in the root directory,
            # because it could take a long time to search a large tree, and it's
            # unlikely someone who keeps scripts in the root would also have
            # some in subdirectories
            if $is_root_dir; then
                debug "  Ignored subdirectory '$file'"
            else
                debug "  Registered subdirectory '$file' to parent command '$prefix$name'"
                executable_to_command[$realfile]="$prefix$name"
                debug "  Searching subdirectory '$file'"
                register_commands "$file" "$prefix$name "
            fi
        elif [[ ! -x $file ]]; then
            if ! $is_root_dir; then
                non_executable_files+=("$file")
            fi
            debug "  Ignored non-executable file '$file'"
        else
            commands+=("$prefix$name")
            command_to_executable["$prefix$name"]=$realfile
            executable_to_command[$realfile]="$prefix$name"
            debug "  Registered command '$prefix$name' for executable '$realfile'"
        fi
    done
}

debug "Searching '$bin_directory' for scripts"
register_commands "$bin_directory"

process_aliases

#===============================================================================
# Helpers to match input to commands
#===============================================================================

command_matches() {
    local type=$1
    local target=$2
    local command=$3

    # Check for a match of the given type
    if [[ $type = exact ]]; then
        [[ "$command" = "$target" ]]
    elif [[ $type = with-extension ]]; then
        [[ "$command" = "$target".* ]]
    elif [[ $type = subcommands ]]; then
        [[ "$command" = "$target "* ]]
    elif [[ $type = prefix ]]; then
        [[ "$command" = "$target"* ]]
    else
        bug "Invalid \$type '$type' passed to command_matches()" # kcov-ignore-line: This should never be happen
    fi

    # If it doesn't match, return false
    # shellcheck disable=SC2181
    if [[ $? -gt 0 ]]; then
        debug "    No match for '$command'"
        return 1
    fi

    return 0
}

is_hidden_command() {
    local command=$1
    local target=${2-}

    # We can't just match on $command, because it may be the parent command that is hidden
    prefix_length=${#target}
    if [[ $prefix_length -gt 0 ]]; then
        command="${command:$prefix_length}"
    else
        command=" $command"
    fi

    # Technically this would break on a command containing a space followed by an underscore,
    # like 'a _b' - but that's such an edge case I'm not going to complicate this any more!
    [[ $command = *" _"* || $command = *" '_"* ]]
}

matching_commands=()

find_matching_commands() {
    local type=$1
    local target=$2

    debug "  Looking for command '$target' ($type)"

    local -A commands_matching_aliases
    local command

    for alias in "${aliases[@]}"; do
        if command_matches "$type" "$target" "$alias"; then
            command=${alias_to_command[$alias]}
            commands_matching_aliases[$command]=true
            debug "    Found matching alias '$alias' for command '$command'"
        fi
    done

    matching_commands=()
    for command in "${commands[@]}"; do
        if ${commands_matching_aliases[$command]-false}; then
            debug "    Found matching command '$command' (from alias)"
            matching_commands+=("$command")
        elif command_matches "$type" "$target" "$command"; then
            debug "    Found matching command '$command'"
            matching_commands+=("$command")
        fi
    done
}

matching_commands_shared_prefix() {
    local prefix=$1
    local prefix_length=${#prefix}

    local shared_next_command=''

    for command in "${matching_commands[@]}"; do
        # Remove the common prefix
        local remaining=${command:$prefix_length}

        if [[ ! $remaining = *' '* ]]; then
            continue
        fi

        local next_command=${remaining/ */}

        if [[ -z $shared_next_command ]]; then
            shared_next_command=$next_command
        elif [[ "$next_command" != "$shared_next_command" ]]; then
            # Not unique
            return 1
        fi
    done

    if [[ -n $shared_next_command ]]; then
        echo "$prefix$shared_next_command"
    else
        # No subcommands found
        return 1
    fi
}

#===============================================================================
# Tab completion setup
#===============================================================================

last_parameter=0

if [[ $action = 'complete-bash' ]]; then
    debug "Tab completion setup:"
    debug "  COMP_LINE='$COMP_LINE'"
    debug "  COMP_POINT=$COMP_POINT"

    # Remove everything after the cursor and assign to numbered variables
    args=${COMP_LINE:0:$COMP_POINT}
    debug "  Setting parameters to '$args'"
    set -- $args

    # Remove the command name
    debug "  Removing the first parameter '$1'"
    shift

    # If there is a space at the end, we want to complete the next parameter; otherwise the last one given
    if [[ $args != *' ' ]]; then
        last_parameter=1
    fi
fi

#===============================================================================
# Parse parameters and run the command
#===============================================================================

run_command() {
    if [[ $action = 'complete-bash' ]]; then
        bug "run_command() should not be reached during tab completion" # kcov-ignore-line: This should never be happen
    elif [[ $action = 'print' ]]; then
        debug_exit "Would print:" "$@"
        echo "$@"
        exit
    else
        debug_exit "Would execute:" "$@"
        exec "$@"
    fi
}

run_command_if_only_one_match() {
    if [[ ${#matching_commands[@]} -eq 1 ]]; then
        command=${matching_commands[0]}
        executable=${command_to_executable[$command]}
        export BIN_COMMAND="$exe$full_command"
        run_command "$executable" "$@"
    else
        debug "    There were ${#matching_commands[@]} matches - not running command"
    fi
}

# If no command is given, we will list all available commands
list_title='Available commands'
list_commands=("${commands[@]}")

# Loop through each argument until we find a matching command
debug "Processing positional parameters"
current_directory=$bin_directory
full_command=''

while [[ $# -gt $last_parameter ]]; do
    subcommand=$1
    shift

    # Build up the entered command in canonical format
    full_command+=" $subcommand"

    # Check if there's an exact match - run it if so
    find_matching_commands exact "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there's an almost-exact match with an added extension - run it if so
    find_matching_commands with-extension "${full_command:1}"
    run_command_if_only_one_match "$@"

    # Check if there are any subcommands - move on to the next argument if so
    find_matching_commands subcommands "${full_command:1}"

    if [[ ${#matching_commands[@]} -gt 0 ]]; then
        current_directory="$current_directory/$subcommand"
        list_title='Available subcommands'
        list_commands=("${matching_commands[@]}")
        continue
    fi

    # If we haven't matched anything yet, check whether we should run a fallback instead
    if $shim; then
        debug "No command found - using shim"
        # We want word splitting here
        # shellcheck disable=SC2086
        run_command ${full_command:1} "$@"
    elif [[ -n $fallback ]]; then
        debug "No command found - using fallback"
        # We want word splitting here - the fallback command may contain spaces to separate arguments
        # shellcheck disable=SC2086
        run_command $fallback "$@"
    fi

    # Check if there are any prefix matches
    # We need to check even with --exact so we can list them
    find_matching_commands prefix "${full_command:1}"

    if ! $exact && parent=$(matching_commands_shared_prefix "${full_command:1}"); then
        # If all matching commands have the same parent command, pretend
        # the user typed the full parent command, then continue parsing
        debug "  Expanding partial match to '$parent'"
        current_directory="$current_directory/$parent"
        full_command=" $parent"
        list_title='Matching commands'
        list_commands=("${matching_commands[@]}")
        continue
    fi

    if $exact; then
        debug "    Not running match (if any) because 'exact' is $exact"
    else
        run_command_if_only_one_match "$@"
    fi

    # If there were no prefix matches, stop searching
    if [[ ${#matching_commands[@]} -eq 0 ]]; then
        if $is_root_dir && [[ -d "$current_directory/$subcommand" ]]; then
            fail "Subcommands are not supported with the config option 'dir=$bin_dirname'"
        fi
        if [[ $subcommand = .* && -e "$current_directory/$subcommand" ]]; then
            fail "Command names may not start with '.'"
        fi
        if [[ -f "$current_directory/$subcommand" && ! -x "$current_directory/$subcommand" ]]; then
            fail "'$current_directory/$subcommand' is not executable (chmod +x)" $ERR_NOT_EXECUTABLE
        fi
        fail "Command '${full_command:1}' not found in $bin_directory" $ERR_NOT_FOUND
    fi

    # Otherwise display the list of matches
    list_title='Matching commands'
    list_commands=("${matching_commands[@]}")
    break
done

#===============================================================================
# Tab completion output
#===============================================================================

if [[ $action = 'complete-bash' ]]; then

    # Work out the full prefix we're looking for
    prefix=''
    if [[ -n $full_command ]]; then
        prefix="${full_command:1} "
    fi

    target="$prefix${1-}"

    debug "Looking for commands and aliases starting with '$target'"

    # Look for commands and aliases that match, and collect the first parameter for each
    matches=()
    matching_commands=()

    for command in "${commands[@]}"; do
        if command_matches prefix "$target" "$command"; then
            match=${command#$prefix}
            match=${match/ *}
            matches+=("$match")
            matching_commands+=("$command")
            debug "    Found matching command '$command' => '$match'"
        fi
    done

    for alias in "${aliases[@]}"; do
        if command_matches prefix "$target" "$alias"; then
            command="${alias_to_command[$alias]}"
            if in_array "$command" "${matching_commands[@]}"; then
                debug "    Skipping matching alias '$alias' because the command '$command' has already matched"
            else
                match=${alias#$prefix}
                match=${match/ *}
                matches+=("$match")
                matching_commands+=("$command")
                debug "    Found matching alias '$alias' => '$match' (command='$command')"
            fi
        fi
    done

    # Output the matches and remove duplicates
    for match in "${matches[@]}"; do
        echo "$match"
    done | sort | uniq

    exit

fi

#===============================================================================
# List available/matching commands
#===============================================================================

# Remove the extensions, as long as they are unique
remove_extension() {
    # Can't use ${command%%.*} because it could remove too much ("a.b c" => "a" instead of "a.b")
    # Can't use ${command%.*} because it could remove too little ("a.b.c" => "a.b" instead of "a")
    local command="$1"

    while [[ "$command" =~ (.*?)(\.[a-zA-Z0-9]+)+ ]]; do
        command=${BASH_REMATCH[1]}
    done

    echo "$command"
}

has_duplicate() {
    local short=$1
    local long=$2

    local command

    for command in "${commands[@]}"; do
        case "$command" in
            # Ignore a match to itself
            "$long") continue ;;
                # Matched to the short command, but not the long one
            "$short") return 0 ;;
            "$short."*) return 0 ;;
        esac
    done

    for alias in "${aliases[@]}"; do
        if [[ "$alias" = "$short" ]]; then
            return 0
        fi
    done

    # No matches found
    return 1
}

debug "Determining unique command names for listing"
unique_commands=()

for command in "${list_commands[@]}"; do
    if $is_root_dir && [[ ${command_to_executable[$command]} =~ \.(json|md|txt|yaml|yml)$ ]]; then
        debug "  Ignored common non-executable file type '${command_to_executable[$command]}' in root directory"
        continue
    fi

    if is_hidden_command "$command" "${full_command:1}"; then
        debug "  '$command' is hidden - skipping"
        continue
    fi

    short=$(remove_extension "$command")

    if [[ "$short" = "$command" ]]; then
        debug "  '$command' can't be shortened"
        unique_commands+=("$command")
    elif has_duplicate "$short" "$command"; then
        debug "  '$short' is not unique - using full command name '$command'"
        unique_commands+=("$command")
    else
        debug "  '$command' shortened to '$short'"
        unique_commands+=("$short")
    fi
done

# Calculate the maximum length of a command in the list so we can align the help text
maxlength=0
for command in "${unique_commands[@]}"; do
    if [[ ${#command} -gt $maxlength ]]; then
        maxlength=${#command}
    fi
done

debug "Maximum matching command length is $maxlength"

# Output the list
get_command_aliases() {
    local command=$1
    local command_aliases=''
    local command_alias_count=0

    for alias in "${aliases[@]}"; do
        local target=${alias_to_command[$alias]}
        if [[ "$target" = "$command" ]]; then
            ((command_alias_count += 1))
            command_aliases+=", $alias"
        fi
    done

    if [[ $command_alias_count -eq 1 ]]; then
        echo "alias: ${command_aliases:2}"
    elif [[ $command_alias_count -gt 1 ]]; then
        echo "aliases: ${command_aliases:2}"
    fi
}

debug_exit "Would list ${#unique_commands[@]} matching command(s)"

echo "$TITLE$list_title$RESET"

for command in "${unique_commands[@]}"; do
    command_help=${help[$command]-}
    command_aliases=$(get_command_aliases "$command")

    if [[ -n $command_help && -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help $GREY($command_aliases)$RESET"
    elif [[ -n $command_help ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$command_help"
    elif [[ -n $command_aliases ]]; then
        printf "%s %-${maxlength}s    %s\n" "$exe" "$command" "$GREY($command_aliases)$RESET"
    else
        printf "%s %s\n" "$exe" "$command"
    fi
done

if [[ ${#unique_commands[@]} -eq 0 ]]; then
    echo "${GREY}None found${RESET}"
fi

# List non-executable files, if any
if [[ ${#non_executable_files[@]} -gt 0 ]]; then
    echo
    echo "${WARNING}Warning: The following files are not executable (chmod +x):${RESET}"
    for file in "${non_executable_files[@]}"; do
        echo "$file"
    done
fi
